################################################################################
# wimb_lactobacillaceae_ASV.R v1.2 8/8/2022
################################################################################

# This scrips uses the list of samples generated in the where_is_my_bug script
# to extract ASVs from mindata objects
# In addition it will also get sequences for type strains and sequences
# extracted from the SILVA v138.1 reference and use this combined info
# to generate annotated phylogenetic trees, kmer analysis and clustering, as applicable

# to use this script
# 1. you need to have the script in a folder and make that folder a project
#    folder in RStudio
# 2. the folder must contain a subfolder named FMBN with the FMBN_plus.rds
#    version of FoodMicrobionet (the most recent version can be downloaded from)
#    GitHub (https://github.com/ep142/FoodMicrobionet/tree/master/the_real_thing)
# 3. the folder must also contain further files generated by the other scripts in
#    this work
#    a. lb_ts_seqs.rds a list with 16S RNA gene sequences for type strains
#    b. Lactobacillaceae_metadata_w_outg.txt a df with metadata for the sequences of the
#       type strains and outgroups for the different genera
#    d. Lactobacillaceae_ref_seqs_list.Rdata a list with reference sequences for
#       Lactobacillaceae extracted from SILVA v138.1; again, the slots contain the
#       full length sequences and the sequences for regions V1-V3- V3-V4 and V4
#    e. Lb_SILVA_genus_species_mdata.RDS the metadata for the reference sequences
#    f. pooled_edges_sample_study.rds the samples on which you want to perform the search
#       generated using the where_is_my_bug_v1_5 script
#    g. pooled_edges_sample_study_fenv.rds the food environment samples on which you want
#       to perform the search generated using the where_is_my_bug_v1_5 script
# 4. one level up from the project folder you must have the mindata_SILVAv138_1
#    folder, containing phyloseq objects and further info for FMBN studies 
#    (note that not all study have a mindata file); these are available from Zenodo
#    DOI: 10.5281/zenodo.6954040
# note that f. and g. can be generated with the where_is_my_bug_v1_5_Lactobacillaceae.R
# script

# Install/load packages ---------------------------------------------------

.cran_packages <- c("crayon", "tidyverse", "parallel",  "data.table", "phylotools", 
                    "progress", "beepr", "tictoc", "glue","cowplot", "kmer")
.bioc_packages <- c("BiocManager", "Biostrings", "dada2", "phyloseq", "DECIPHER", "phangorn", 
                    "treeio", "tidytree", "ggtree", "ggtreeExtra")

# dada2 is only needed if you want to re-do taxonomical assignment for sequences
# "treeio", "tidytree", "ggtree", "ggtreeExtra" may require some massaging to install

.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if(!.inst[1]) {
    install.packages("BiocManager")
    .inst <- .bioc_packages %in% installed.packages()
  }
  if(any(!.inst[2:length(.inst)])) {
    BiocManager::install(.bioc_packages[!.inst], ask = F)
  }
}

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(.cran_packages[!.inst])
}
# Load packages into session, and print package version
sapply(c(.cran_packages, .bioc_packages), require, character.only = TRUE)



# the following command detects the number of cores on UNIX/MacOS
nc <- parallel::detectCores(logical = F) # to detect physical cores in MacOS
# for reproducibility reasons
set.seed(100)
# mainly for reproducibility reasons (this will be saved with the work space)
r_version <- R.Version() # in the future may be check that the version running is compatible
# with the script (it only matters if somebody other than myself is using the script)
session_info <- sessionInfo()

# use this option to play a sound when an operation (for example in the make_tree
# function), is completed
play_sound <- T

# a manual color scale for T/F
# TF_colors <- c("#F8766D", "#619CFF")
# names(TF_colors) <- c("FALSE", "TRUE")

# functions ---------------------------------------------------------------

# sample_rows -------------------------------------------------------------

# a function for randomly extracting n rows or less if the df is smaller
sample_rows <- function(df, rows){
  df <- if(dim(df)[1] > rows) {df <- slice_sample(.data = df, n = rows)} else {df}
  return(df)
}


# remove_dupli_seqs -------------------------------------------------------

# a function for removing duplicated sequences from a data frame of sequences
remove_dupli_seqs<-function(seq_df){
  uniques <- !duplicated(seq_df$seq.text)
  seq_df <- seq_df[uniques,]
  return(seq_df)
}


# make_seq_vector ---------------------------------------------------------

# transform the sequences contained in a df (column seq.text) in a character vector + remove N decamers (if any)
# introduced by justConcatenate 

make_seq_vector <- function(seq_df){
  seq_df <- seq_df %>% 
    mutate(seq.text = str_remove(seq.text,"NNNNNNNNNN"))
  seqs <- seq_df$seq.text
  names(seqs) <- seq_df$seq.name
  return(seqs)
}

# make_tree -------------------------------------------------------

# a function for aligning and clustering sequences (taken from the dada2 pipeline)
# returns a text warning or a list containing alignment and maximum-likelihood phylogenetic tree
# part of this function is taken almost verbatim from the Bioconductor workflow for 
# microbiome data analysis (doi 10.12688/f1000research.8986.2)
# keep_time: if T  displays the time taken for each run of the functions
# minseqs and maxseqs are the interval of the number of sequences for which a phylogenetic is generated
# min_num must be defined before running the function
# if progress == T a progress bar is displayed
# this function is taken almost verbatim from the Bioconductor workflow for 
# microbiome data analysis (doi 10.12688/f1000research.8986.2)
# it takes an alignment as an input
# optimization depends on the boot_option (although anova on ML of trees
# created with either method shows that there is no difference, bootstrap
# values will always be 100% with stochastic rearrangement)

make_tree <- function(seqs, 
                      keep_time = T, 
                      minseqs = min_num, 
                      maxseqs = 5000,
                      boot_option = F,
                      progress = F){
  if(keep_time) tic("\nbuilding the phylogenetic tree")
  
  if(length(seqs)<=minseqs | length(seqs)>=maxseqs){
    fitGTR <- "\ntoo few or too many sequences, returning a warning, not a tree\n"
    cat(red(fitGTR))
  } else {
    
    # empty row to console
    cat("\n")
    
    # create an alignment with DECIPHER
    
    alignment <-
      DECIPHER::AlignSeqs(DNAStringSet(seqs),
                          anchor = NA,
                          processors = nc)
    
    # The phangorn package is  used to build a phylogenetic tree.
    # Here we first build a neighbor-joining tree, and then fit a GTR+G+I
    # (Generalized time-reversible with Gamma rate variation)
    # maximum likelihood tree using the neighbor-joining tree as a starting point.
    # transform in phydat object
    phang.align <- phangorn::phyDat(as(alignment, "matrix"), type = "DNA")
    # create distance matrix
    cat(red("\ncreating distance matrix...","\n"))
    dm <- phangorn::dist.ml(phang.align)
    # perform Neighbor joining
    cat(red("\ncreating tree...","\n"))
    treeNJ <- phangorn::NJ(dm) # Note, tip order != sequence order
    # internal maximum likelihood for tree
    cat(red("\nestimating internal ML for tree...", "\n"))
    fit = phangorn::pml(treeNJ, data = phang.align)
    Sys.sleep(5)
    fitGTR <- update(fit, k = 4, inv = 0.2)
    Sys.sleep(5)
    # this is the step taking the longest time
    cat(red("\noptimization, please be patient...","\n"))
    if(boot_option){
      fitGTR <- optim.pml(
        fitGTR,
        model = "GTR",
        optNni = T
      )
    } else {
      fitGTR <- optim.pml(
        fitGTR,
        model = "GTR",
        optInv = TRUE,
        optGamma = TRUE,
        rearrangement = "stochastic",
        control = pml.control(trace = 0)
      )
    }
    cat(red("\nfitGTR object created\n"))
    # this is actually an object/list which contains the tree in the slot $tree
    # and the alignment in slot $data
    
  }
  
  if(progress & exists("pb")){
    cat(red("\nProgress in creating phylogenetic trees...\n"))
    pb$tick()
    cat("\n")
  }
  
  if(keep_time) toc()
  if(play_sound) beep(sound = 6)
  ali_tree_list <- list(algnmt = alignment, tree = fitGTR)
  return(ali_tree_list)
}


# boot_tree ---------------------------------------------------------------

# a function for bootstrapping maximum likelihood phylogenetic trees

boot_tree <- function(fit, n_boot = 100, mcore = T){
  bs_pml <- bootstrap.pml(fit, bs = n_boot, multicore = mcore, mc.cores = nc) # 
  treeBS <- plotBS(fit$tree, bs_pml)
  return(treeBS)
}


# make_rel -------------------------------------------------------------
# a function for calculating relativa abundance for ASVs in ASV tables
# takes a column (equivalent to a sample) as an input
make_rel <- function(num_vec){
  tot <- sum(num_vec)
  rel_ab <- num_vec/tot
  return(rel_ab)
}


# join_tree_metadata ------------------------------------------------------
# a function for joining the tree metadata
# x is a tidytree object
# y is the region to select for (the name of the slot of the list)
# met_df is the metadata data frame
# by_var is the variable used for the join
join_tree_metadata <- function(x, y, met_df, by_var = "label"){
  if(class(x) != "treedata") stop("\nx must be a treedata object")
  if(!("data.frame" %in% class(met_df))) stop("\nmet_df must be data frame")
  # filter by region and rename seq.name 
  met_df <- dplyr::filter(met_df, region2 == y)
  met_df <- dplyr::rename(met_df, label = seq.name)
  if(any(duplicated(met_df$label))) stop("\nduplicated sequences in metadata")
  ann_treedata <- left_join(x, met_df, by = by_var)
  return(ann_treedata)
}


# make_tree_plot ----------------------------------------------------------

# a function for making a tree plot object
# I am not doing much effort at error trapping
# x: is a treedata object
# ttitle: is the plot title, default is NULL
# t_layout: is the tree layout
#     one of 'rectangular', 'dendrogram', 'slanted', 'ellipse', 'roundrect', 
#     'fan', 'circular', 'inward_circular', 'radial', 'equal_angle', 'daylight' or 'ape'
# tips: controls which tips are included in the tree plot; 
#     must be one of "all" (all tips, the default), "ref" (only reference tips, including  
#     outgroup if any, "noref" excludes the reference tips if any)
# hxp, vxp: is the horizontal/vertical expand value, as fraction of the tree plot size; 
#     useful for accomodating long labels. The default is 0.2
# ldrz: is the ladderize option, by default T, set to false to get a cladogram
# reroot: an option for rerooting the tree plot (if an outgroup node is available)
#     by default T; ignored if outgroup not available
# lbl_size, lbl_alpha, lbl_offset: size, alpha and offset of labels for tips
# size_vec: a vector of size 2 for the range of the size of the symbols
# sh_lg: sets show legend for tippoints, default to T
# min_rab: parameter for removing tips on the basis of their relative abundance

make_tree_plot <- function(x, ttitle = NULL, t_layout = "rectangular", 
                           tips = "all", hxp = 0.2, vxp = 0.1, ldrz = T, reroot = T,
                           lbl_size = 1, lbl_alpha= 0.2, lbl_offset = 0.05, 
                           size_vec = c(1,6), sh_lg = T, min_rab = 1E-4){
  # first, check that the input is a treedata object, return an error if not
  if(class(x) != "treedata") stop("\nThis function only works with treedata objects\n")
  # drop tips, depending on the "which" parameter
  if(!(tips %in% c("all", "ref", "noref"))) stop("\nthe tips parameter must be one of: all, ref, noref\n")
  ref_tips <- as_tibble(x) %>% dplyr::filter(str_detect(seqtype, "refseq")) %>% pull(node)
  FMBN_tips <- as_tibble(x) %>% dplyr::filter(str_detect(seqtype, "ASV")) %>% pull(node)
  tips_to_drop <- switch(tips,
                         all = NA_integer_,
                         ref = FMBN_tips,
                         noref = ref_tips
  )
  sel_x <- x
  if (tips != "all"){
    sel_x <- sel_x %>% drop.tip(tips_to_drop)
  }
  # optionally filtering by abundance
  if("max_rel_ab" %in% names(sel_x@extraInfo)){
    tips_to_drop <- dplyr::filter(as_tibble(sel_x), max_rel_ab<min_rab) %>% pull(label)
    sel_x <- sel_x %>% drop.tip(tips_to_drop)
  }
  # optionally re-root the tree (will not reroot if outgroup is missing)
  if(reroot){
    outgroup_node <- sel_x %>% 
      as_tibble() %>%
      dplyr::filter(seqtype == "outgroup") %>%
      slice_head(n=1) %>%
      pull(node)
    if(!is_empty(outgroup_node)){
      sel_x <- treeio::root(phy = sel_x, outgroup = outgroup_node)
    }
  }
  
  tree_plot <- ggtree(sel_x, layout = t_layout, ladderize = ldrz) + 
    geom_tiplab(size = I(lbl_size), alpha = I(lbl_alpha), offset = lbl_offset)
  # options for size
  if("max_rel_ab" %in% names(sel_x@extraInfo)){
    tree_plot <- tree_plot +
      geom_tippoint(mapping = aes(size = log_max_rel_ab, colour = food_group), 
                    show.legend = sh_lg) +
      geom_treescale() +
      hexpand(hxp) +
      labs(title = ttitle,
           color = "food group",
           size = "log(max_rel_ab)")
  } else {
    tree_plot <- tree_plot +
      geom_tippoint(mapping = aes(colour = food_group), size = I(3), 
                    show.legend = sh_lg) +
      geom_treescale() +
      hexpand(hxp) +
      labs(title = ttitle,
           color = "food group")
  }
  tree_plot <- tree_plot +
    scale_size_continuous(range = size_vec, limits = c(log10(min_rab), 0)) +
    theme_tree() +
    theme(plot.title = element_text(hjust = 0.5))
  return(tree_plot)
}

# kmer analysis -----------------------------------------------------------

# This function
# a. takes as an input a named character vector with sequences (argument seq_char)
# b. converts it to DNA.bin
# c. uses functions of package kmer with kmer_n length (default = 5) to
#    1. optionally calculate kmer distance matrix (calculated with mbed optional seed_vector if kmer_n>5)
#    2. return OTU membership vector at two similarity levels (sim_lvl_1 = 0.97, sim_lvl_2 = 0.99)
#    3. optionally perform MDS and return results and coordinates (which otherwise are null)
# results ar returned as a list

# I am not doing any effort for at error trapping (not even checking if required packages
# have been loaded: anyway kmer is needed and also ape, as a dependency, but it is loaded
# by phylotools), and crayon, for messages. It might also worth adding an option
# for the method in kmer::otu(); right now defaults to farthest, which I think is OK


kmer_analysis <- function(seq_char, kmer_n = 5, 
                          sim_lvl_1 = 0.97, sim_lvl_2 = 0.99,
                          calc_dist = T, perform_MDS = T, seed_vector = NULL){
  # create DNA_bin object
  cat(red("\ncreating DNAbin object...","\n"))
  seq_DNAbin <- as.DNAbin(DNAStringSet(seq_char))
  # creating the distance matrix
  
  if(calc_dist) {
    cat(red("\ncreating kmer distance matrix...","\n"))  
    if(kmer_n>5){
      kdist_mat <- mbed(seq_DNAbin, k = kmer_n, seeds = seed_vector)
    } else {
      kdist_mat <- kdistance(seq_DNAbin, k = kmer_n) 
    }
  } else {
    kdist_mat = NULL
  }
  
  cat(red("\ncalculating OTUs, similarity lvl 1", sim_lvl_1, "...", "\n"))
  otus_lvl1 <- otu(seq_DNAbin, k = kmer_n, threshold = sim_lvl_1, method = "farthest", nstart = 20)
  
  otus_lvl1_df <- tibble::enframe(otus_lvl1) %>%
    rename(seq_abbr = name, OTU = value) %>%
    mutate(seq_abbr = str_remove(seq_abbr, "\\*"))
  
  cat(red("\ncalculating OTUs, similarity lvl 2", sim_lvl_2, "...", "\n"))
  otus_lvl2 <- otu(seq_DNAbin, k = kmer_n, threshold = sim_lvl_2, method = "farthest", nstart = 20)
  
  otus_lvl2_df <- tibble::enframe(otus_lvl2) %>%
    rename(seq_abbr = name, OTU = value) %>%
    mutate(seq_abbr = str_remove(seq_abbr, "\\*"))
  
  if(calc_dist & perform_MDS) {
    cat(red("\nMDS...", "\n"))
    # this is a PCOA
    MDS_result <- cmdscale(kdist_mat, list. =T)
    MDS_coord <- as.data.frame(MDS_result$points) %>%
      rownames_to_column(var = "seq_abbr") %>%
      rename(dim1 = V1, dim2 = V2)
  } else {
    MDS_result <- MDS_coord <- NULL
  }
  
  
  kmer_list <- list(
    kmer_length = kmer_n,
    OTUsimlvl1 = sim_lvl_1,
    OTUsimlvl2 = sim_lvl_2,
    DNAbin = seq_DNAbin,
    kmer_dist_mat = kdist_mat,
    otus_1 = otus_lvl1,
    otus_2 = otus_lvl2,
    otus_1_df = otus_lvl1_df,
    otus_2_df = otus_lvl2_df,
    MDS_res = MDS_result,
    MDS_coord_df = MDS_coord
  )
  
  return(kmer_list)
}



# setup section ends here -----------------------------------------------

###############################################################################

taxon_level <- "family" # perhaps should limit to order, as a maximum?
# choice is between "order", "family", "genus"
taxon_to_search <- c("Lactobacillaceae", "Leuconostocaceae")

# loading data ------------------------------------------------------------

is_it_there <- "FMBN_plus.rds" %in% list.files(file.path("FMBN"))

if(is_it_there){
  FMBN <- readRDS(file.path(
    "FMBN", "FMBN_plus.rds"))
} else {
  cat(red("\nWARNING: unable to locate the FMBN database\n"))
}

# load the reference sequences and sequences for type strains
load(file = "Lactobacillaceae_ref_seqs_list.Rdata")
# the first slot contains full length sequences and the others contain
# regions extracted on the basis of matches with commonly used primers
# the first 374 are type strains

# metadata for the type strains (with outgroup information)
ts_metadata <- read_tsv("Lactobacillaceae_metadata_w_outg.txt")
outgroups <- ts_metadata %>% distinct(Genus, group_16S, group_color,outgroup)

# metadata for ref seqs
SILVA_genus_species <- readRDS(file = "Lb_SILVA_genus_species_mdata.RDS")

#  the samples on which you want to perform the search
pooled_edges_sample_study <- readRDS("pooled_edges_sample_study.rds")

# the food environment samples on which you want to perform the search
pooled_edges_sample_study_fenv <- readRDS("pooled_edges_sample_study_fenv.rds")

which(!(names(pooled_edges_sample_study_fenv) %in% names(pooled_edges_sample_study)))
names(pooled_edges_sample_study_fenv)[9]
pooled_edges_sample_study_fenv <- dplyr::select(pooled_edges_sample_study_fenv, -description)

# samples to process
samples_to_process <- "all" # fsamples, fenv

pooled_edges <- switch(samples_to_process,
                       all = bind_rows(pooled_edges_sample_study, pooled_edges_sample_study_fenv),
                       fsamples = pooled_edges_sample_study,
                       fenv = pooled_edges_sample_study_fenv)


# this is a list of the genera for which I might want to create dendrograms;
# technically one could use a loop or a functional to automate tree generation and 
# plotting

genera_to_plot <- c("Holzapfelia", "Schleiferilactobacillus","Dellaglioa")




###############################################################################

# get the ASV, if possible ------------------------------------------------

samples_to_search <- pooled_edges %>% 
  select(sampleId, studyId, target1, target2, Seq_accn)

# get the list of Seq_accn
seq_accns <- dplyr::filter(samples_to_search, !is.na(Seq_accn)) %>%
  arrange(Seq_accn) %>%
  pull(Seq_accn) %>%
  unique(.)
# 145 seq accns


# get the files in the mindata folder
mindata_list <- list.files(file.path("..", "mindata_SILVAv138_1"))

# 211 mindata available
nrow(FMBN$studies) # this version of FMBN has 211 studies

mindata_accn <- str_remove(mindata_list, "_mindata.RDS")
# get the files to use
mindata_to_use <- mindata_list[which(mindata_accn %in% seq_accns)]
# make a list for essential data
seq_accns <- sort(seq_accns[which(seq_accns %in% mindata_accn)])

# taxon_lvl is just an alias of taxon_level which works with the taxa table in phyloseq objects
taxon_lvl <- case_when(
  taxon_level == "genus" ~ "Genus",
  taxon_level == "family" ~ "Family",
  taxon_level == "order" ~ "Order"
)

# use a loop to get the sequences from the mindata objects ----------------

# NOTE FOR SELF: may be this should become a function to be used with map
#                may be add diagnostics
#                Technically, I should introduce a control for reverse complement
#                sequences (rev_compl == T in the mindata list), but this was introduced only
#                after v4.1 of FoodMicrobionet

seq_list <- vector(mode = "list", length = length(mindata_to_use))
otu_table_list <- vector(mode = "list", length = length(mindata_to_use))

for (i in seq_along(seq_list)) {
  mindata_temp <-
    readRDS(file.path("..", "mindata_SILVAv138_1", mindata_to_use[i]))
  physeqtemp <- mindata_temp$physeq
  
  taxtab_temp <- as(tax_table(physeqtemp), "matrix")
  
  taxtab_temp_df <- as.data.frame(taxtab_temp) %>%
    rownames_to_column(var = "orig_seq") %>%
    dplyr::filter(.data[[taxon_lvl]] %in% taxon_to_search)
  
  if(nrow(taxtab_temp_df)<1){
    cat("\n no taxa to return for", seq_accns[i],"\n")
    next
  }
  seqtab_temp <- t(as(otu_table(physeqtemp), "matrix"))
  seqtab_temp <- as.data.frame(seqtab_temp) %>%
    select(pull(taxtab_temp_df, orig_seq)) %>%
    dplyr::filter(rowSums(.)>0)
  
  study_details <-
    dplyr::filter(FMBN$studies, Seq_accn == mindata_temp$Study_accn) %>%
    select(studyId, FMBN_version, target, region, Seq_accn)
  
  slice_argument <- rep(1, each = nrow(taxtab_temp_df))
  study_details <- dplyr::slice(study_details, slice_argument)
  taxtab_temp_df <- bind_cols(taxtab_temp_df, study_details)
  # handling reverse complement sequences
  if(rev_compl %in% names(mindata_temp)){
    if(rev_compl){
      rcseqs <- Biostrings::DNAStringSet(taxtab_temp_df$orig_seq, use.names = F)
      rcseqs <- Biostrings::reverseComplement(rcseqs)
      taxtab_temp_df$orig_seq <- as.character(taxtab_temp_df$orig_seq)
      # same for OTU table
      rcseqs <- Biostrings::DNAStringSet(colnames(seqtab_temp), use.names = F)
      rcseqs <- Biostrings::reverseComplement(rcseqs)
      colnames(seqtab_temp) <- as.character(rcseqs)
      rm(rcseqs)
    } else {
      cat(red("\nSequences are in the right orientation, no change needed...\n"))
    }
  }
  seq_list[[i]] <- taxtab_temp_df
  otu_table_list[[i]] <- seqtab_temp
  names(seq_list)[i] <- names(otu_table_list)[i] <- mindata_temp$Study_accn
  cat("\nsequence extraction for study ", mindata_temp$Study_accn, ", ", i, " of ", 
      length(mindata_to_use), "...\n", sep = "")
}

# remove temporary objects
rm(mindata_temp, physeqtemp, taxtab_temp, taxtab_temp_df, slice_argument, study_details, i)
gc()

# 142 mindata parsed

# remove empty elements (not needed)

# seq_list <- seq_list[!is.na(names(seq_list))]
# otu_table_list <- otu_table_list[!is.na(names(otu_table_list))]

# let's create a data frame from the list

seq_list_df <- map_dfr(seq_list, bind_rows, .id = "Seq_accn") %>% 
  mutate(seq.name = str_c(Seq_accn, str_trunc(Genus, 7, side = "right", ellipsis = ""), row_number(), sep = "_"))
# remove NA and HT002
seq_list_df <- seq_list_df %>% dplyr::filter(!is.na(Genus) & Genus != "HT002")

# transform Genus in a ordered factor
genera <- sort(unique(pooled_edges$genus))
genera
# I am reordering in the order they appear in Qiao et al., 2022
# Qiao, N., Wittouck, S., Mattarelli, P., Zheng, J., Lebeer, S., Felis, G.E., Gänzle, M.G., 2022. After the storm—Perspectives on the taxonomy of Lactobacillaceae. Jds Commun. https://doi.org/10.3168/jdsc.2021-0183
genera_ordered <- genera[c(13, 2, 10, 4, 5, 14, 1, 27, 11, 24, 15, 22, 6, 21, 19, 26, 12, 7, 3, 16, 28, 18, 25, 20, 9, 29, 23, 8, 17)]
# Acetilactobacillus, Convivina, Periweissella are missing (the last two are missing in SILVA v138.1)
genera_ordered
length(genera_ordered)
length((distinct(seq_list_df, Genus)) %>% pull())

seq_list_df <- seq_list_df %>% mutate(seq_group = factor(Genus, levels = genera_ordered))


# create a label for the identification
if(!"Species" %in% colnames(seq_list_df)) seq_list_df$Species <- NA_character_

# may be in the future add a variable with the Study, just to merge the database of ASVs

seq_list_df[is.na(seq_list_df)] <- ""
seq_list_df <- seq_list_df %>%
  mutate(s_label = {
    ifelse(Kingdom == "", "Other",
           ifelse(Phylum == "", Kingdom, 
                  ifelse(Class == "", Phylum,
                         ifelse(Order == "", Class, 
                                ifelse(Family == "", Order, 
                                       ifelse(Genus == "", Family, 
                                              ifelse(Species == "", Genus, paste(Genus, Species, sep =" "))))))))
  })


# phylogenetic trees and kmer analysis ------------------------------------

# this section if very difficult to automate because results from several sections
# of the script require visual inspection and ad hoc action

# make phylogenetic trees --------------------------------------------------------

# prepare sequences -------------------------------------------------------

# options

# optionally remove seqs created with just concatenate
# this is not really necessary, because before clustering they are going to be
# removed; anyway they are bound to cause problems
remove_concatenated <- T
# optionally remove duplicated seqs
remove_duplicates <- F
# add reference sequences
add_ref_seqs <- T
# optionally reduce the number of reference sequences (including outgroups) by random sampling
sample_seqs <- T
ref_seqs_to_keep <- 2
# optionally add type strains
add_ts <- T
# min_number of seqs to use in phylogenetic trees
min_num <- 10
# optionally add outgroups
add_out<-T
# use a progress bar for alignment and phylogenetic tree
use_pb <- T
# option for getting ASV sources from seq abundance tables: may be very expensive in terms of time
get_ASV_sources <- T


# Let's start with Dellaglioa ---------------------------------------------

# extract sequences from df, if any, in two slots, one for V1-V3 and another for V3-V4
genus_to_select <- "Dellaglioa"
selected_seqs <- seq_list_df %>% 
  dplyr::filter(Genus == genus_to_select) %>%
  mutate(seqtype = "ASV") %>%
  select(seq.name, seq.text = orig_seq, seqtype, region)
# optionally remove paired end sequences obtained with the justConcatenate option 
if(remove_concatenated){
  selected_seqs <- selected_seqs %>% dplyr::filter(!str_detect(selected_seqs$seq.text, "NNN"))
}

sel_seqs_list <- list(
  V1V3 = (selected_seqs %>% dplyr::filter(region == "V1-V3")),
  V3V4 = (selected_seqs %>% dplyr::filter(region == "V3-V4"))
)

# oprionally remove duplicated sequences
if(remove_duplicates){
  sel_seqs_list_unique <- map(.x = sel_seqs_list, .f = remove_dupli_seqs)
} else {
  sel_seqs_list_unique <- sel_seqs_list
}
   
# now add ref_seqs (optionally)

if(add_ref_seqs){
  refseqs <- SILVA_genus_species %>%
    dplyr::filter(Genus == genus_to_select) %>% pull(seq.name)
  refseqs_V1V3 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V1V3[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V1-V3", length(refseqs))
    )
  refseqs_V3V4 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V3V4[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V3-V4", length(refseqs))
  )

  # optionally reduce the numebr of reference sequences
  if(sample_seqs){
    refseqs_V1V3_all <- refseqs_V1V3
    refseqs_V1V3 <- sample_rows(refseqs_V1V3_all, ref_seqs_to_keep)
    refseqs_V3V4_all <- refseqs_V3V4
    refseqs_V3V4 <- sample_rows(refseqs_V3V4_all, ref_seqs_to_keep)
  }
  
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, refseqs_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, refseqs_V3V4)
  }
# optionally add type strains

if(add_ts){
  ts_seqs <- ts_metadata %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(seq_abbr)
  ts_V1V3 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V1V3[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V1-V3", length(ts_seqs))
  )
  ts_V3V4 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V3V4[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V3-V4", length(ts_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, ts_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, ts_V3V4)
}
# optionally add outgroups

if(add_out){
  out_seqs <- outgroups %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(outgroup)
  out_V1V3 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V1V3[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V1-V3", length(out_seqs))
  )
  out_V3V4 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V3V4[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V3-V4", length(out_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, out_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, out_V3V4)
}


View(sel_seqs_list_unique$V1V3)
# the number of sequences in each slot
map(.x = sel_seqs_list_unique, .f =nrow)

# transform the sequences in a list of named text vectors + remove N decamers (if any)
# introduced by justConcatenate 

sel_seq_txt <- map(sel_seqs_list_unique, make_seq_vector)

# min_number of seqs to use in phylogenetic trees

to_tree <- map_int(sel_seq_txt, length)>=min_num
seqs_to_tree <- sel_seq_txt[to_tree]

# do alignment and clustering ---------------------------------------------

# creates a container for the progress bar

if(use_pb){
  pb <- progress_bar$new(total = length(seqs_to_tree))
  pb$tick(0)
  }

# use map with optional progress bar with function make_tree
# set progress to use_pb if you want a progress bar, otherwise don't use it (the default is F)
# TAKES TIME, BE PATIENT #
alignm_trees <- map(.x = seqs_to_tree, .f = make_tree, progress = use_pb)
rm(pb)

# view the alignment
# BrowseSeqs(alignm_trees$V1V3$algnmt)
# BrowseSeqs(alignm_trees$V3V4$algnmt)
# there is very clearly a problem with some sequences from study ERP107282
# which should be removed
# seqs_to_tree$V3V4 <- seqs_to_tree$V3V4[!str_detect(names(seqs_to_tree$V3V4), "ERP107282")]
# seqs_to_tree$V1V3 <- seqs_to_tree$V1V3[!str_detect(names(seqs_to_tree$V1V3), "ERP004317")]
# I am repeating the alignment 
# alignm_trees <- map(.x = seqs_to_tree, .f = make_tree, progress = use_pb)

# get only slots of class pml
fitGTR_obj <- list(V1V3 = alignm_trees[[1]][[2]], V3V4 = alignm_trees[[2]][[2]])
pml_slots <- unname(which(map_chr(fitGTR_obj, class)=="pml"))
trees_pml <- fitGTR_obj[pml_slots]


# prepare sequence metadata -----------------------------------------------

selected_seqs_metadata <- bind_rows(selected_seqs,
                                    refseqs_V1V3,
                                    refseqs_V3V4,
                                    ts_V1V3,
                                    ts_V3V4,
                                    out_V1V3,
                                    out_V3V4)
# sequences are labeled by study; it would be hard to label them by sample, unless
# you want to pick the sample in which a sequence has the highest relative abundance
# in a given study, or may be count the occurrencies

# may give warnings
selected_seqs_metadata <- tidyr::separate(selected_seqs_metadata, seq.name,
                                          into = c("Seq_accn", "genus", "id"),
                                          remove = F) %>%
  select(-genus, -id) %>%
  dplyr::filter(region == "V1-V3" | region == "V3-V4")

selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                    select(FMBN$studies, Seq_accn, food_group,geoloc))

# Now, technically, I would have to look for the ASVs in the sequence tables and get the samples
# in which they are found and further metadata from that

# the following section is probably expensive in terms of time and error prone. It will be run
# optionally
# since left_join is used I am not bothering at removing badly aligned studies

if(get_ASV_sources){
  # make a container (a list, will be filled with data frames)
  # must fix the issue of duplicated ASVs (which will not appear in the tree)
  studies <- dplyr::filter(selected_seqs_metadata, seqtype == "ASV") %>%
    distinct(Seq_accn) %>% pull()
  ASV_metadata_list <- vector(mode = "list", length = length(studies))
  
  # I will first iterate over study/Seq_accn and within that over ASVs
  # I will only retrieve samples in which a given ASV has >min_ab
  # now min abundance needs not be 0, can be 0.01, 0.1 etc.
  min_ab <- 0 # only retrieve samples in which the abundance is larger than this
  for (i in seq_along(studies)){
    study <- studies[i]
    cat(red("study ", i, " of ", length(studies), ": ", study, "\n", sep = ""))
    seq.names <- dplyr::filter(selected_seqs_metadata, Seq_accn == study) %>% pull(seq.name)
    ASV_to_search_for <- selected_seqs_metadata %>%
      dplyr::filter(Seq_accn == study) %>%
      pull(seq.text)
    names(ASV_to_search_for) <- seq.names
    otu_table <- t(otu_table_list[[which(names(otu_table_list) == study)]])
    otu_table <- as.data.frame(apply(otu_table, 2, make_rel))
    rows_to_keep <- rownames(otu_table) %in% ASV_to_search_for
    samples_with_ASVs <- otu_table[rows_to_keep,]
    cols_to_keep <- which(colSums(samples_with_ASVs)>0)
    samples_with_ASVs <- dplyr::select(samples_with_ASVs,all_of(cols_to_keep))
    # create a container with the sources
    ASV_sources <- vector(mode = "list", length = nrow(samples_with_ASVs))
    for(j in 1:nrow(samples_with_ASVs)){
      # initialize fId and fId_max
      fId <- NULL
      fId_max <- NULL
      smpls <- colnames(samples_with_ASVs)
      max_ab <- max(samples_with_ASVs[j,])
      max_col <- which(samples_with_ASVs[j,] == max_ab)[1]
      smpl_max_id <- colnames(samples_with_ASVs)[max_col]
      fId_max <- dplyr::filter(FMBN$samples, SRA_run == smpl_max_id) %>% pull(foodId)
      if(length(smpls)>0){
        for(k in seq_along(smpls)){
          if(k == 1){
            fId <- dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId)
          } else {
            fId <- c(fId, dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId))
          }
        }
      } else {
        fId <- "below threshold"
      }
      # get unique values and collapse if longer than 1
      fId <- unique(fId)
      if(length(fId>1)) {fId <- glue_collapse(fId, sep = ", ")}
      # assemble a df to return
      ASV_sources[[j]] <- tibble(
        ASV = rownames(samples_with_ASVs)[j],
        seq.name = seq.names[j],
        max_rel_ab = max_ab,
        foodIds = fId,
        foodIdmax = fId_max
      )
    }
    ASV_metadata_list[[i]] <- map_dfr(ASV_sources, bind_rows)
  }
  ASV_metadata_df <- map_dfr(ASV_metadata_list, bind_rows)
  
  selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                      dplyr::select(ASV_metadata_df, seq.name:foodIdmax))
  
  # removing object which I won't need later (which, by the way is the reason why I should
  # remember to use functions and not loops)
  rm(i,j,k, fId, fId_max, max_ab, seq.names, smpl_max_id, smpls, 
     samples_with_ASVs, ASV_sources, ASV_to_search_for, study, otu_table,
     max_col, cols_to_keep, rows_to_keep, ASV_metadata_list,
     ASV_metadata_df)
  
}

# final fix, need to create a second column for target
selected_seqs_metadata <- selected_seqs_metadata %>%
  mutate(region2 = str_remove(region, "-"))

# make treedata objects -----------------------------------------------------------


tidytrees <- map(trees_pml, as.treedata, type = "ml")

selected_seqs_metadata <- selected_seqs_metadata %>% 
  mutate(food_group = if_else(is.na(food_group),"ref",food_group),
         geoloc = if_else(is.na(geoloc),"ref",geoloc))
if(get_ASV_sources){
  selected_seqs_metadata <- selected_seqs_metadata %>% 
    mutate(log_max_rel_ab = if_else(is.na(max_rel_ab), 0, log10(max_rel_ab)))
}

# View(as_tibble(tidytrees[[1]])) # V1V3
# View(as_tibble(tidytrees[[2]])) # V3V4


#  annotate trees ---------------------------------------------------------

# join metadata 
# this is tricky because I need to filter the metadata by region, to avoid duplicates in the
# outgroup, type strains and refseqs

tidytrees_w_ann <- map2(.x = tidytrees, .y = names(tidytrees), .f = join_tree_metadata,
                        met_df = selected_seqs_metadata, by_var = "label")

# tidytrees_w_ann <- vector(mode = "list", length = length(tidytrees))
# for(i in seq_along(tidytrees)){
#   if(class(tidytrees[[i]]) != "treedata") stop("\nx must be a treedata object")
#   if(!("data.frame" %in% class(selected_seqs_metadata))) stop("\nmetadata must be data frame")
#   # filter by region and rename seq.name 
#   met_df <- dplyr::filter(selected_seqs_metadata, region2 == names(tidytrees)[i])
#   met_df <- dplyr::rename(met_df, label = seq.name)
#   if(any(duplicated(met_df$label))) stop("\nduplicated sequences in metadata")
#   tidytrees_w_ann[[i]] <- left_join(tidytrees[[i]], met_df)
#   names(tidytrees_w_ann)[i]<-names(tidytrees)[i]
# }
# rm(i, met_df)

# class(tidytrees_w_ann[[1]])
# View(as_tibble(tidytrees_w_ann[[1]]))
# View(as_tibble(tidytrees[[1]]))
# class(tidytrees_w_ann[[2]])
# View(as_tibble(tidytrees_w_ann[[2]]))
# View(as_tibble(tidytrees[[2]]))

# make tree plots ---------------------------------------------------------

# create a list of tree plots; options within the make_tree_plot function 
# can be used to customize
# the trees can be printed or further annotated

# I am using a loop rather than map to get the tree title

tree_plots <- vector(mode = "list", length = length(tidytrees_w_ann))

# I am not bothering with a progress bar here
# if needed, one could theoretically filter by abundance using drop.tip()

tic("\ncreating tree plots")
for (i in seq_along(tidytrees_w_ann)){
  tree_plots[[i]] <- try(make_tree_plot(tidytrees_w_ann[[i]], ldrz = T,
                                        ttitle = str_c(genus_to_select, names(tidytrees_w_ann)[i], sep = ", "),
                                        tips = "all", reroot = T, lbl_size = 1, lbl_alpha = 0.3, vxp = 0.5,
                                        size_vec = c(0.5,5), min_rab = 1E-3))
  names(tree_plots)[i] <- names(tidytrees_w_ann)[i]
}
toc()
print(tree_plots[[1]])
print(tree_plots[[2]])


# only keep the tree plots
tree_plots_classes <- map(.x = tree_plots, .f = class)
tree_plots_slots <- map_lgl(.x = tree_plots_classes, .f = ~("ggtree" %in% .x))
tree_plots <- tree_plots[tree_plots_slots]

names(tidytrees_w_ann)

save(tree_plots, file = "tree_plots_Dellaglioa_ovlp.RData")
ggsave(tree_plots[[2]], file = "dellaglioaV3V4_ovlp.tiff", width = 5, height = 7, dpi = 300)
ggsave(tree_plots[[1]], file = "dellaglioaV1V3_ovlp.tiff", width = 5, height = 7, dpi = 300)
selseq_metadata_Dellaglioa <- selected_seqs_metadata


# repeating with Holzapfelia ----------------------------------------------


# extract sequences from df, if any, in two slots, one for V1-V3 and another for V3-V4
genus_to_select <- "Holzapfelia"
selected_seqs <- seq_list_df %>% 
  dplyr::filter(Genus == genus_to_select) %>%
  mutate(seqtype = "ASV") %>%
  select(seq.name, seq.text = orig_seq, seqtype, region)
# optionally remove paired end sequences obtained with the justConcatenate option 
if(remove_concatenated){
  selected_seqs <- selected_seqs %>% dplyr::filter(!str_detect(selected_seqs$seq.text, "NNN"))
}

sel_seqs_list <- list(
  V1V3 = (selected_seqs %>% dplyr::filter(region == "V1-V3")),
  V3V4 = (selected_seqs %>% dplyr::filter(region == "V3-V4"))
)

# oprionally remove duplicated sequences
if(remove_duplicates){
  sel_seqs_list_unique <- map(.x = sel_seqs_list, .f = remove_dupli_seqs)
} else {
  sel_seqs_list_unique <- sel_seqs_list
}

# now add ref_seqs (optionally)

if(add_ref_seqs){
  refseqs <- SILVA_genus_species %>%
    dplyr::filter(Genus == genus_to_select) %>% pull(seq.name)
  refseqs_V1V3 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V1V3[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V1-V3", length(refseqs))
  )
  refseqs_V3V4 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V3V4[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V3-V4", length(refseqs))
  )
  
  # optionally reduce the numebr of reference sequences
  if(sample_seqs){
    refseqs_V1V3_all <- refseqs_V1V3
    refseqs_V1V3 <- sample_rows(refseqs_V1V3_all, ref_seqs_to_keep)
    refseqs_V3V4_all <- refseqs_V3V4
    refseqs_V3V4 <- sample_rows(refseqs_V3V4_all, ref_seqs_to_keep)
  }
  
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, refseqs_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, refseqs_V3V4)
}
# optionally add type strains

if(add_ts){
  ts_seqs <- ts_metadata %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(seq_abbr)
  ts_V1V3 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V1V3[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V1-V3", length(ts_seqs))
  )
  ts_V3V4 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V3V4[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V3-V4", length(ts_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, ts_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, ts_V3V4)
}
# optionally add outgroups

if(add_out){
  out_seqs <- outgroups %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(outgroup)
  out_V1V3 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V1V3[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V1-V3", length(out_seqs))
  )
  out_V3V4 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V3V4[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V3-V4", length(out_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, out_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, out_V3V4)
}


View(sel_seqs_list_unique$V1V3)
# the number of sequences in each slot
map(.x = sel_seqs_list_unique, .f =nrow)

# transform the sequences in a list of named text vectors + remove N decamers (if any)
# introduced by justConcatenate 

sel_seq_txt <- map(sel_seqs_list_unique, make_seq_vector)

# min_number of seqs to use in phylogenetic trees

to_tree <- map_int(sel_seq_txt, length)>=min_num
seqs_to_tree <- sel_seq_txt[to_tree]

# do alignment and clustering ---------------------------------------------

# creates a container for the progress bar

if(use_pb){
  pb <- progress_bar$new(total = length(seqs_to_tree))
  pb$tick(0)
}

# use map with optional progress bar with function make_tree
# set progress to use_pb if you want a progress bar, otherwise don't use it (the default is F)
# TAKES TIME, BE PATIENT #
alignm_trees <- map(.x = seqs_to_tree, .f = make_tree, progress = use_pb)
rm(pb)

# view the alignment
# BrowseSeqs(alignm_trees$V1V3$algnmt)
# BrowseSeqs(alignm_trees$V3V4$algnmt)


# get only slots of class pml
fitGTR_obj <- list(V1V3 = alignm_trees[[1]][[2]], V3V4 = alignm_trees[[2]][[2]])
pml_slots <- unname(which(map_chr(fitGTR_obj, class)=="pml"))
trees_pml <- fitGTR_obj[pml_slots]


# prepare sequence metadata -----------------------------------------------

selected_seqs_metadata <- bind_rows(selected_seqs,
                                    refseqs_V1V3,
                                    refseqs_V3V4,
                                    ts_V1V3,
                                    ts_V3V4,
                                    out_V1V3,
                                    out_V3V4)
# sequences are labeled by study; it would be hard to label them by sample, unless
# you want to pick the sample in which a sequence has the highest relative abundance
# in a given study, or may be count the occurrencies

# may give warnings
selected_seqs_metadata <- tidyr::separate(selected_seqs_metadata, seq.name,
                                          into = c("Seq_accn", "genus", "id"),
                                          remove = F) %>%
  select(-genus, -id) %>%
  dplyr::filter(region == "V1-V3" | region == "V3-V4")

selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                    select(FMBN$studies, Seq_accn, food_group,geoloc))

# Now, technically, I would have to look for the ASVs in the sequence tables and get the samples
# in which they are found and further metadata from that

# the following section is probably expensive in terms of time and error prone. It will be run
# optionally
# since left_join is used I am not bothering at removing badly aligned studies

if(get_ASV_sources){
  # make a container (a list, will be filled with data frames)
  # must fix the issue of duplicated ASVs (which will not appear in the tree)
  studies <- dplyr::filter(selected_seqs_metadata, seqtype == "ASV") %>%
    distinct(Seq_accn) %>% pull()
  ASV_metadata_list <- vector(mode = "list", length = length(studies))
  
  # I will first iterate over study/Seq_accn and within that over ASVs
  # I will only retrieve samples in which a given ASV has >min_ab
  # now min abundance needs not be 0, can be 0.01, 0.1 etc.
  min_ab <- 0 # only retrieve samples in which the abundance is larger than this
  for (i in seq_along(studies)){
    study <- studies[i]
    cat(red("study ", i, " of ", length(studies), ": ", study, "\n", sep = ""))
    seq.names <- dplyr::filter(selected_seqs_metadata, Seq_accn == study) %>% pull(seq.name)
    ASV_to_search_for <- selected_seqs_metadata %>%
      dplyr::filter(Seq_accn == study) %>%
      pull(seq.text)
    names(ASV_to_search_for) <- seq.names
    otu_table <- t(otu_table_list[[which(names(otu_table_list) == study)]])
    otu_table <- as.data.frame(apply(otu_table, 2, make_rel))
    rows_to_keep <- rownames(otu_table) %in% ASV_to_search_for
    samples_with_ASVs <- otu_table[rows_to_keep,]
    cols_to_keep <- which(colSums(samples_with_ASVs)>0)
    samples_with_ASVs <- dplyr::select(samples_with_ASVs,all_of(cols_to_keep))
    # create a container with the sources
    ASV_sources <- vector(mode = "list", length = nrow(samples_with_ASVs))
    for(j in 1:nrow(samples_with_ASVs)){
      # initialize fId and fId_max
      fId <- NULL
      fId_max <- NULL
      smpls <- colnames(samples_with_ASVs)
      max_ab <- max(samples_with_ASVs[j,])
      max_col <- which(samples_with_ASVs[j,] == max_ab)[1]
      smpl_max_id <- colnames(samples_with_ASVs)[max_col]
      fId_max <- dplyr::filter(FMBN$samples, SRA_run == smpl_max_id) %>% pull(foodId)
      if(length(smpls)>0){
        for(k in seq_along(smpls)){
          if(k == 1){
            fId <- dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId)
          } else {
            fId <- c(fId, dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId))
          }
        }
      } else {
        fId <- "below threshold"
      }
      # get unique values and collapse if longer than 1
      fId <- unique(fId)
      if(length(fId>1)) {fId <- glue_collapse(fId, sep = ", ")}
      # assemble a df to return
      ASV_sources[[j]] <- tibble(
        ASV = rownames(samples_with_ASVs)[j],
        seq.name = seq.names[j],
        max_rel_ab = max_ab,
        foodIds = fId,
        foodIdmax = fId_max
      )
    }
    ASV_metadata_list[[i]] <- map_dfr(ASV_sources, bind_rows)
  }
  ASV_metadata_df <- map_dfr(ASV_metadata_list, bind_rows)
  
  selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                      dplyr::select(ASV_metadata_df, seq.name:foodIdmax))
  
  # removing object which I won't need later (which, by the way is the reason why I should
  # remember to use functions and not loops)
  rm(i,j,k, fId, fId_max, max_ab, seq.names, smpl_max_id, smpls, 
     samples_with_ASVs, ASV_sources, ASV_to_search_for, study, otu_table,
     max_col, cols_to_keep, rows_to_keep, ASV_metadata_list,
     ASV_metadata_df)
  
}

# final fix, need to create a second column for target
selected_seqs_metadata <- selected_seqs_metadata %>%
  mutate(region2 = str_remove(region, "-"))

# make treedata objects -----------------------------------------------------------

tidytrees <- map(trees_pml, as.treedata, type = "ml")

selected_seqs_metadata <- selected_seqs_metadata %>% 
  mutate(food_group = if_else(is.na(food_group),"ref",food_group),
         geoloc = if_else(is.na(geoloc),"ref",geoloc))
if(get_ASV_sources){
  selected_seqs_metadata <- selected_seqs_metadata %>% 
    mutate(log_max_rel_ab = if_else(is.na(max_rel_ab), 0, log10(max_rel_ab)))
}

# View(as_tibble(tidytrees[[1]])) # V1V3
# View(as_tibble(tidytrees[[2]])) # V3V4


#  annotate trees ---------------------------------------------------------

# join metadata 
# this is tricky because I need to filter the metadata by region, to avoid duplicates in the
# outgroup, type strains and refseqs

tidytrees_w_ann <- map2(.x = tidytrees, .y = names(tidytrees), .f = join_tree_metadata,
                        met_df = selected_seqs_metadata, by_var = "label")

# tidytrees_w_ann <- vector(mode = "list", length = length(tidytrees))
# for(i in seq_along(tidytrees)){
#   if(class(tidytrees[[i]]) != "treedata") stop("\nx must be a treedata object")
#   if(!("data.frame" %in% class(selected_seqs_metadata))) stop("\nmetadata must be data frame")
#   # filter by region and rename seq.name 
#   met_df <- dplyr::filter(selected_seqs_metadata, region2 == names(tidytrees)[i])
#   met_df <- dplyr::rename(met_df, label = seq.name)
#   if(any(duplicated(met_df$label))) stop("\nduplicated sequences in metadata")
#   tidytrees_w_ann[[i]] <- left_join(tidytrees[[i]], met_df)
#   names(tidytrees_w_ann)[i]<-names(tidytrees)[i]
# }
# rm(i, met_df)

# class(tidytrees_w_ann[[1]])
# View(as_tibble(tidytrees_w_ann[[1]]))
# View(as_tibble(tidytrees[[1]]))
# class(tidytrees_w_ann[[2]])
# View(as_tibble(tidytrees_w_ann[[2]]))
# View(as_tibble(tidytrees[[2]]))

# make tree plots ---------------------------------------------------------

# create a list of tree plots; options within the make_tree_plot function 
# can be used to customize
# the trees can be printed or further annotated

# I am using a loop rather than map to get the tree title

tree_plots <- vector(mode = "list", length = length(tidytrees_w_ann))

# I am not bothering with a progress bar here
# if needed, one could theoretically filter by abundance using drop.tip()

tic("\ncreating tree plots")
for (i in seq_along(tidytrees_w_ann)){
  tree_plots[[i]] <- try(make_tree_plot(tidytrees_w_ann[[i]], ldrz = T,
                                        ttitle = str_c(genus_to_select, names(tidytrees_w_ann)[i], sep = ", "),
                                        tips = "all", reroot = T, lbl_size = 1, lbl_alpha = 0.3, vxp = 0.5,
                                        size_vec = c(0.5,5), min_rab = 1E-3))
  names(tree_plots)[i] <- names(tidytrees_w_ann)[i]
}
toc()
print(tree_plots[[1]])
print(tree_plots[[2]])


# only keep the tree plots
tree_plots_classes <- map(.x = tree_plots, .f = class)
tree_plots_slots <- map_lgl(.x = tree_plots_classes, .f = ~("ggtree" %in% .x))
tree_plots <- tree_plots[tree_plots_slots]

names(tidytrees_w_ann)

save(tree_plots, file = "tree_plots_Holzapfelia_ovlp.RData")
ggsave(tree_plots[[2]], file = "HolzapfeliaV3V4_ovlp.tiff", width = 5, height = 7, dpi = 300)
ggsave(tree_plots[[1]], file = "HolzapfeliaV1V3_ovlp.tiff", width = 5, height = 7, dpi = 300)
selseq_metadata_Holzapfelia <- selected_seqs_metadata


# Schleiferilactobacillus -------------------------------------------------


# extract sequences from df, if any, in two slots, one for V1-V3 and another for V3-V4
genus_to_select <- "Schleiferilactobacillus"
selected_seqs <- seq_list_df %>% 
  dplyr::filter(Genus == genus_to_select) %>%
  mutate(seqtype = "ASV") %>%
  select(seq.name, seq.text = orig_seq, seqtype, region)
# optionally remove paired end sequences obtained with the justConcatenate option 
if(remove_concatenated){
  selected_seqs <- selected_seqs %>% dplyr::filter(!str_detect(selected_seqs$seq.text, "NNN"))
}

sel_seqs_list <- list(
  V1V3 = (selected_seqs %>% dplyr::filter(region == "V1-V3")),
  V3V4 = (selected_seqs %>% dplyr::filter(region == "V3-V4"))
)

# oprionally remove duplicated sequences
if(remove_duplicates){
  sel_seqs_list_unique <- map(.x = sel_seqs_list, .f = remove_dupli_seqs)
} else {
  sel_seqs_list_unique <- sel_seqs_list
}

# now add ref_seqs (optionally)

if(add_ref_seqs){
  refseqs <- SILVA_genus_species %>%
    dplyr::filter(Genus == genus_to_select) %>% pull(seq.name)
  refseqs_V1V3 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V1V3[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V1-V3", length(refseqs))
  )
  refseqs_V3V4 <- tibble(
    seq.name = refseqs,
    seq.text = ref_seq_list$V3V4[refseqs],
    seqtype = rep("refseq", length(refseqs)),
    region = rep("V3-V4", length(refseqs))
  )
  
  # optionally reduce the numebr of reference sequences
  if(sample_seqs){
    refseqs_V1V3_all <- refseqs_V1V3
    refseqs_V1V3 <- sample_rows(refseqs_V1V3_all, ref_seqs_to_keep)
    refseqs_V3V4_all <- refseqs_V3V4
    refseqs_V3V4 <- sample_rows(refseqs_V3V4_all, ref_seqs_to_keep)
  }
  
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, refseqs_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, refseqs_V3V4)
}
# optionally add type strains

if(add_ts){
  ts_seqs <- ts_metadata %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(seq_abbr)
  ts_V1V3 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V1V3[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V1-V3", length(ts_seqs))
  )
  ts_V3V4 <- tibble(
    seq.name = ts_seqs,
    seq.text = ref_seq_list$V3V4[ts_seqs],
    seqtype = rep("ts", length(ts_seqs)),
    region = rep("V3-V4", length(ts_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, ts_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, ts_V3V4)
}
# optionally add outgroups

if(add_out){
  out_seqs <- outgroups %>% 
    dplyr::filter(Genus == genus_to_select) %>%
    pull(outgroup)
  out_V1V3 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V1V3[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V1-V3", length(out_seqs))
  )
  out_V3V4 <- tibble(
    seq.name = out_seqs,
    seq.text = ref_seq_list$V3V4[out_seqs],
    seqtype = rep("outgroup", length(out_seqs)),
    region = rep("V3-V4", length(out_seqs))
  )
  sel_seqs_list_unique$V1V3 <- bind_rows(sel_seqs_list_unique$V1V3, out_V1V3)
  sel_seqs_list_unique$V3V4 <- bind_rows(sel_seqs_list_unique$V3V4, out_V3V4)
}


View(sel_seqs_list_unique$V1V3)
# the number of sequences in each slot
map(.x = sel_seqs_list_unique, .f =nrow)

# transform the sequences in a list of named text vectors + remove N decamers (if any)
# introduced by justConcatenate 

sel_seq_txt <- map(sel_seqs_list_unique, make_seq_vector)

# min_number of seqs to use in phylogenetic trees

to_tree <- map_int(sel_seq_txt, length)>=min_num
seqs_to_tree <- sel_seq_txt[to_tree]

# do alignment and clustering ---------------------------------------------

# creates a container for the progress bar

if(use_pb){
  pb <- progress_bar$new(total = length(seqs_to_tree))
  pb$tick(0)
}

# use map with optional progress bar with function make_tree
# set progress to use_pb if you want a progress bar, otherwise don't use it (the default is F)
# TAKES TIME, BE PATIENT #
alignm_trees <- map(.x = seqs_to_tree, .f = make_tree, progress = use_pb)
rm(pb)

# view the alignment
# BrowseSeqs(alignm_trees$V1V3$algnmt)
# BrowseSeqs(alignm_trees$V3V4$algnmt)


# get only slots of class pml
fitGTR_obj <- list(V1V3 = alignm_trees[[1]][[2]], V3V4 = alignm_trees[[2]][[2]])
pml_slots <- unname(which(map_chr(fitGTR_obj, class)=="pml"))
trees_pml <- fitGTR_obj[pml_slots]


# prepare sequence metadata -----------------------------------------------

selected_seqs_metadata <- bind_rows(selected_seqs,
                                    refseqs_V1V3,
                                    refseqs_V3V4,
                                    ts_V1V3,
                                    ts_V3V4,
                                    out_V1V3,
                                    out_V3V4)
# sequences are labeled by study; it would be hard to label them by sample, unless
# you want to pick the sample in which a sequence has the highest relative abundance
# in a given study, or may be count the occurrencies

# may give warnings
selected_seqs_metadata <- tidyr::separate(selected_seqs_metadata, seq.name,
                                          into = c("Seq_accn", "genus", "id"),
                                          remove = F) %>%
  select(-genus, -id) %>%
  dplyr::filter(region == "V1-V3" | region == "V3-V4")

selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                    select(FMBN$studies, Seq_accn, food_group,geoloc))

# Now, technically, I would have to look for the ASVs in the sequence tables and get the samples
# in which they are found and further metadata from that

# the following section is probably expensive in terms of time and error prone. It will be run
# optionally
# since left_join is used I am not bothering at removing badly aligned studies

if(get_ASV_sources){
  # make a container (a list, will be filled with data frames)
  # must fix the issue of duplicated ASVs (which will not appear in the tree)
  studies <- dplyr::filter(selected_seqs_metadata, seqtype == "ASV") %>%
    distinct(Seq_accn) %>% pull()
  ASV_metadata_list <- vector(mode = "list", length = length(studies))
  
  # I will first iterate over study/Seq_accn and within that over ASVs
  # I will only retrieve samples in which a given ASV has >min_ab
  # now min abundance needs not be 0, can be 0.01, 0.1 etc.
  min_ab <- 0 # only retrieve samples in which the abundance is larger than this
  for (i in seq_along(studies)){
    study <- studies[i]
    cat(red("study ", i, " of ", length(studies), ": ", study, "\n", sep = ""))
    seq.names <- dplyr::filter(selected_seqs_metadata, Seq_accn == study) %>% pull(seq.name)
    ASV_to_search_for <- selected_seqs_metadata %>%
      dplyr::filter(Seq_accn == study) %>%
      pull(seq.text)
    names(ASV_to_search_for) <- seq.names
    otu_table <- t(otu_table_list[[which(names(otu_table_list) == study)]])
    otu_table <- as.data.frame(apply(otu_table, 2, make_rel))
    rows_to_keep <- rownames(otu_table) %in% ASV_to_search_for
    samples_with_ASVs <- otu_table[rows_to_keep,]
    cols_to_keep <- which(colSums(samples_with_ASVs)>0)
    samples_with_ASVs <- dplyr::select(samples_with_ASVs,all_of(cols_to_keep))
    # create a container with the sources
    ASV_sources <- vector(mode = "list", length = nrow(samples_with_ASVs))
    for(j in 1:nrow(samples_with_ASVs)){
      # initialize fId and fId_max
      fId <- NULL
      fId_max <- NULL
      smpls <- colnames(samples_with_ASVs)
      max_ab <- max(samples_with_ASVs[j,])
      max_col <- which(samples_with_ASVs[j,] == max_ab)[1]
      smpl_max_id <- colnames(samples_with_ASVs)[max_col]
      fId_max <- dplyr::filter(FMBN$samples, SRA_run == smpl_max_id) %>% pull(foodId)
      if(length(smpls)>0){
        for(k in seq_along(smpls)){
          if(k == 1){
            fId <- dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId)
          } else {
            fId <- c(fId, dplyr::filter(FMBN$samples, SRA_run %in% smpls) %>% pull(foodId))
          }
        }
      } else {
        fId <- "below threshold"
      }
      # get unique values and collapse if longer than 1
      fId <- unique(fId)
      if(length(fId>1)) {fId <- glue_collapse(fId, sep = ", ")}
      # assemble a df to return
      ASV_sources[[j]] <- tibble(
        ASV = rownames(samples_with_ASVs)[j],
        seq.name = seq.names[j],
        max_rel_ab = max_ab,
        foodIds = fId,
        foodIdmax = fId_max
      )
    }
    ASV_metadata_list[[i]] <- map_dfr(ASV_sources, bind_rows)
  }
  ASV_metadata_df <- map_dfr(ASV_metadata_list, bind_rows)
  
  selected_seqs_metadata <- left_join(selected_seqs_metadata, 
                                      dplyr::select(ASV_metadata_df, seq.name:foodIdmax))
  
  # removing object which I won't need later (which, by the way is the reason why I should
  # remember to use functions and not loops)
  rm(i,j,k, fId, fId_max, max_ab, seq.names, smpl_max_id, smpls, 
     samples_with_ASVs, ASV_sources, ASV_to_search_for, study, otu_table,
     max_col, cols_to_keep, rows_to_keep, ASV_metadata_list,
     ASV_metadata_df)
  
}

# final fix, need to create a second column for target
selected_seqs_metadata <- selected_seqs_metadata %>%
  mutate(region2 = str_remove(region, "-"))

# make treedata objects -----------------------------------------------------------

tidytrees <- map(trees_pml, as.treedata, type = "ml")

selected_seqs_metadata <- selected_seqs_metadata %>% 
  mutate(food_group = if_else(is.na(food_group),"ref",food_group),
         geoloc = if_else(is.na(geoloc),"ref",geoloc))
if(get_ASV_sources){
  selected_seqs_metadata <- selected_seqs_metadata %>% 
    mutate(log_max_rel_ab = if_else(is.na(max_rel_ab), 0, log10(max_rel_ab)))
}

# View(as_tibble(tidytrees[[1]])) # V1V3
# View(as_tibble(tidytrees[[2]])) # V3V4


#  annotate trees ---------------------------------------------------------

# join metadata 
# this is tricky because I need to filter the metadata by region, to avoid duplicates in the
# outgroup, type strains and refseqs

tidytrees_w_ann <- map2(.x = tidytrees, .y = names(tidytrees), .f = join_tree_metadata,
                        met_df = selected_seqs_metadata, by_var = "label")

# tidytrees_w_ann <- vector(mode = "list", length = length(tidytrees))
# for(i in seq_along(tidytrees)){
#   if(class(tidytrees[[i]]) != "treedata") stop("\nx must be a treedata object")
#   if(!("data.frame" %in% class(selected_seqs_metadata))) stop("\nmetadata must be data frame")
#   # filter by region and rename seq.name 
#   met_df <- dplyr::filter(selected_seqs_metadata, region2 == names(tidytrees)[i])
#   met_df <- dplyr::rename(met_df, label = seq.name)
#   if(any(duplicated(met_df$label))) stop("\nduplicated sequences in metadata")
#   tidytrees_w_ann[[i]] <- left_join(tidytrees[[i]], met_df)
#   names(tidytrees_w_ann)[i]<-names(tidytrees)[i]
# }
# rm(i, met_df)

# class(tidytrees_w_ann[[1]])
# View(as_tibble(tidytrees_w_ann[[1]]))
# View(as_tibble(tidytrees[[1]]))
# class(tidytrees_w_ann[[2]])
# View(as_tibble(tidytrees_w_ann[[2]]))
# View(as_tibble(tidytrees[[2]]))

# make tree plots ---------------------------------------------------------

# create a list of tree plots; options within the make_tree_plot function 
# can be used to customize
# the trees can be printed or further annotated

# I am using a loop rather than map to get the tree title

tree_plots <- vector(mode = "list", length = length(tidytrees_w_ann))

# I am not bothering with a progress bar here
# if needed, one could theoretically filter by abundance using drop.tip()

tic("\ncreating tree plots")
for (i in seq_along(tidytrees_w_ann)){
  tree_plots[[i]] <- try(make_tree_plot(tidytrees_w_ann[[i]], ldrz = T,
                                        ttitle = str_c(genus_to_select, names(tidytrees_w_ann)[i], sep = ", "),
                                        tips = "all", reroot = T, lbl_size = 1, lbl_alpha = 0.3, vxp = 0.5,
                                        size_vec = c(0.5,5), min_rab = 1E-3))
  names(tree_plots)[i] <- names(tidytrees_w_ann)[i]
}
toc()
print(tree_plots[[1]])
print(tree_plots[[2]])


# only keep the tree plots
tree_plots_classes <- map(.x = tree_plots, .f = class)
tree_plots_slots <- map_lgl(.x = tree_plots_classes, .f = ~("ggtree" %in% .x))
tree_plots <- tree_plots[tree_plots_slots]

names(tidytrees_w_ann)

save(tree_plots, file = "tree_plots_Holzapfelia_ovlp.RData")
ggsave(tree_plots[[2]], file = "SchleiferilbV3V4_ovlp.tiff", width = 5, height = 7, dpi = 300)
ggsave(tree_plots[[1]], file = "SchleiferilbV1V3_ovlp.tiff", width = 5, height = 7, dpi = 300)
selseq_metadata_Schleiferilb <- selected_seqs_metadata


# doing kmer analysis -----------------------------------------------------------

# I am attempting a kmer analysis on the three genera
# let's first build a list for the sequences
# an ad hoc function
pull_sequences <- function(df, rgn){
  sq <- dplyr::filter(df, region2 == rgn) %>% pull(seq.text)
  names(sq) <- dplyr::filter(df, region2 == rgn) %>% pull(seq.name)
  return(sq)
}

DHS_seqs <- list(
  Dellaglioa_V1V3 = pull_sequences(selseq_metadata_Dellaglioa, "V1V3"),
  Dellaglioa_V3V4 = pull_sequences(selseq_metadata_Dellaglioa, "V3V4"),
  Holzapfelia_V1V3 = pull_sequences(selseq_metadata_Holzapfelia, "V1V3"),
  Holzapfelia_V3V4 = pull_sequences(selseq_metadata_Holzapfelia, "V3V4"),
  Schleiferilb_V1V3 = pull_sequences(selseq_metadata_Schleiferilb, "V1V3"),
  Schleiferilb_V3V4 = pull_sequences(selseq_metadata_Schleiferilb, "V1V3")
)

kmers <- map(.x = DHS_seqs, .f = kmer_analysis, sim_lvl_2 = 0.9865)

# too many OTUs, does not make sense
# let's try a MDS plot

a<- kmers$Holzapfelia_V3V4$MDS_coord_df
a<-left_join(a, rename(selseq_metadata_Holzapfelia, seq_abbr = seq.name))
a <- a %>%
  mutate(log_max_rel_ab = if_else(is.na(max_rel_ab), 0, log_max_rel_ab)) %>%
  left_join(select(ts_metadata, seq_abbr, Genus)) %>%
  mutate(Genus =if_else(is.na(Genus), "Holzapfelia", Genus))
ggplot(a, mapping = aes(x= dim1, y = dim2, color = food_group, size = log_max_rel_ab, shape = Genus)) +
  geom_point()

# not very interpretable, I am dropping it

# Credits and copyright ---------------------------------------------------


# Assume that this is overall under MIT licence

# Copyright 2022 Eugenio Parente
# Permission is hereby granted, free of charge, to any person obtaining 
# a copy of this software and associated documentation files (the "Software"), 
# to deal in the Software without restriction, including without limitation 
# the rights to use, copy, modify, merge, publish, distribute, sub-license, 
# and/or sell copies of the Software, and to permit persons to whom the Software 
# is furnished to do so, subject to the following conditions:
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
# SOFTWARE.

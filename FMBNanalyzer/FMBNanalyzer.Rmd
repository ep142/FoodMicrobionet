---
title: "FMBNanalyzer.Rmd"
subtitle: "A .rmd document for generating reports using data extracted from FMBN"
author: "E. Parente, Scuola SAFE, Universit√† degli Studi della Basilicata"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    df_print: paged
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# Preparatory steps -------------------------------------------------------

# install/load packages 
# need to use plyr:: because of conflicts
# there are also other potential conflicts between vegan and bipartite
.cran_packages <- c("plyr", "reshape2", "gplots", "tidyverse", "knitr",
                    "randomcoloR", "bipartite", "RColorBrewer",
                    "ggrepel", "vegan")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(.cran_packages[!.inst])
}
sapply(.cran_packages, require, 
       character.only = TRUE)

opar <- par(no.readonly = T)
set.seed(1234)
#########1#########2#########3#########4#########5#########6#########7#########8


```

v2.2 4/1/2022

# How do I use this document?  

The purpose of this .Rmd document is to generate a report with a number of descriptive graphs and tables (and save them, as applicable) using data extracted from ShinyFMBN (find more on [GitHub](https://github.com/ep142/FoodMicrobionet) or on [Mendeley Data](https://data.mendeley.com/datasets/8fwwjpm79y/4)) an app to explore the [FoodMicrobionet database](http://www.foodmicrobionet.org) of metataxonomic data on the composition of bacterial communities in foods.  
To use this document you need to:

* perform a search in ShinyFMBN and export the __agg__ file: see the manual for ShinyFMBN on [Mendeley Data](https://data.mendeley.com/datasets/8fwwjpm79y/4) for further details  

* put the file (you will find it in the output -> aggdata folder, located in the app folder) in a new folder containing this template  

* [create a RStudio project](https://support.rstudio.com/hc/en-us/articles/200526207-Using-RStudio-Projects) for that folder  

* set the options for filtering, saving etc. in the chunk below  

* knit the document (the default is to .html, but you can change the YAML header (or choose the appropriate option in the Knit menu) to obtain .pdf (need LaTex) or MS Word documents  

Any graph will be saved in the same folder. A few chunks have the include oprion set to FALSE: this mean that their output will not be included. You can change this by setting `include = T`.   
Knowledge of [Rmarkdown](https://rmarkdown.rstudio.com/docs/articles/rmarkdown.html) and a rudimentary knowledge of R is useful but not essential.  
__Please note__ a few graphs may not print correctly in the report. To adjust this you need to fiddle with the code. If you are not knowledgeable with the specific functions being used don't do that; in general the graphs will be saved correctly. As a general piece of advice: avoid putting too many things in a graph.  

## Known issues.  

The document should knit without problems if you hit the Knit icon in RStudio. You may see some warnings (some are more frequent if your projects are on a remote drive in MacOS, i.e. Google drive):

*  cleaning the working environment or restarting R before running this script may prevent some problems.

*  if you see a warning that .png graphs cannot be saved this might be due to the fact that you have the file in a folder syncing with Google Drive. The issue disappears when you move everything to your local drive or use Dropbox  

*  some graphs are generated using random palettes rather than brewer's palettes (which are nicer). If you don't like the colors try starting a new RStudio session and knitting again (or using a lower number of samples/sample groups or selecting more stringent parameters for the selection of taxa, which is also wiser.)  

*  some calculations are slow and memory + CPU intensive: this is especially true for rarefaction analysis, calculation of networks stats and module inference. Please be patient (or select a more manageable number of sample/sample groups and taxa); in fact, it might be difficult to run the whole analysis with 8 Gb RAM. In addition, if you choose .tiff as a graph output format and select a high value for graph resolution, the graphic output can be pretty large in terms of disk space (and further slow the execution).    

*  if you re-run the document graphs and tables will be overwritten.  

There are two other options you can consider as an alternative to saving _aggdata in the Shiny app and using this document to generate a report:  

*  save a [phyloseq](https://joey711.github.io/phyloseq/) file and use it in your own script: this is usually more flexible, because phyloseq functions are much more powerful than those used here. If you are not familiar with the phyloseq package you can try the phyloseq file with [Shiny Phyloseq](https://joey711.github.io/shiny-phyloseq/), a Shiny app which provides an interactive interface. In addition phyloseq objects are used as an input by many other R packages on microbiome analysis.  

*  save data in a format usable with [MicrobiomeAnalyst](http://microbiomeanalyst.ca), which provides an excellent web interface for graphical and statistical analysis of microbiota data.  

**Please remember**: in FoodMicrobionet during analysis of raw sequences OTUs or ASVs are aggregated in taxa with the same annotation; further aggregation may then be performed during extraction of data with the ShinyFMBN app. IN the code below I am using OTUs rather loosely.   

```{r loaddata_setoptions, include=FALSE}
filelist <- list.files()
# there must be only one file ending with _aggRDS in the project folder
input_file_name <- filelist[str_detect(filelist, "_agg.RDS")]
file_name_prefix <- str_remove(input_file_name, "_agg.RDS")
file_name <- basename(file_name_prefix)
input_data <- readRDS(input_file_name)
# this is a list, containing the following
#   studies the study table
#   OTU_table the OTU table (taxa are columns) with absolute freqs
#   OTU_table_relf OTU table (taxa are rows, a_label) with rel freqs
#   sample_metadata the sample metadata
#   taxa_metadata the taxa metadata
#   edge_table the OTU_table_relf in long format, with frequencies in %
#   node_table info on sample and OTU nodes
#   i_graph an igraph bipartite object
#   references data frame containing the references
#   version text describing the FMBN version
#   sample_agg the level of aggregation for samples
#   tax_agg the level of aggregation for taxa
#   diagnostic_f a diagnostic which would prevent sample aggregation in the app

# check if the data are in the right format
check_names <- names(input_data) == c("studies","OTU_table", "OTU_table_relf", 
                                      "sample_metadata", "taxa_metadata", 
                                      "edge_table", "node_table", "i_graph", 
                                      "references", "version", "sample_agg", 
                                      "tax_agg", "diagnostic_f")
length(check_names) == sum(check_names)

#########1#########2#########3#########4#########5#########6#########7#########8
# Set options -------------------------------------------------------------
#########1#########2#########3#########4#########5#########6#########7#########8
verbose_output <- T
# this prints extra output (tables mostly). Set to F if you don't want it.
# options for saving graphs
savegraph <- T 
# set savegraph to T if you want to save graphs (some graphs won't be displayed, only saved)
# use F if you don't want to save
graphresolution <- 300 # in dpi
graphsizein <- 7 # size in inches, overridden in some graphs
graphtype <- "tif" # alternative value is "pdf", avoid using "jpg"
gfileext <- ifelse (graphtype == "pdf", ".pdf", ".tiff") 

# options for number of OTU groups in sample and OTU palettes
overrides <- F # set to T if you want more than 15 categories in sample palettes
overrideOTU <- F # set to T if you want more than 15 categories in OTU palettes

# The "Other" column has no taxonomic meaning unless it is an aggregate of
# several OTUs (see instructions in the FMBN_make_files* script) and will be
# removed by default. The "Chloroplast" and "Mitochondria" columns only indicate  
# contamination with chloroplast or mitochondria  DNA/RNA and should also be  
# removed. Set to F if you want to keep these columns in OTU tables.
# Eukaryota can also be removed
removeOther <- T
removeKonly <- T # removes the taxa which have been identified only at the level of Kingdom
removeChloroplast <- T
removeMitochondria <- T
removeEukaryota <- T

# options for filtering samples and OTUs
# if filtersamples == T the sample filter will be applied (overridden if sample_agg == "exp. code")
# if filterOTUs == T the maxrelab filter will be applied

filtersamples <- T
filterOTUs <- T
# filter for OTU abundance. OTUs with a maximum relative abundance < abtreshold
# will be removed or pooled (see below)
# keep the value low or you will loose too many OTUs between filtering and
# rarefaction
abtreshold <- 0.005

# options for taxa prevalence filter (only applicable when sample aggregation is sample)
prev_filter <- F
prev_treshold <- 0.05 # as fraction of samples
prev_filter_flag <- F

# flags for filtering, will be set to true if filtering is performed
filtersamples_flag <- F
filterOTU_flag <- F

# samples/sample groups with less than minsampleab sequences will be removed
minsampleab <- 1000 

# rarefy? if T vegan::rrarefy() will be used to extract a random rarefied
# matrix. If raremin is T will rarefy to the closest hundred below the
# minimum number of sequences, otherwise will rarefy to raren.
# The default is F, although rarefaction will be performed for bipartite
# analysis 
rareoption <- T
raremin <- T
raren <- 10000
rarefy_flag <- F # will be set to T if rarefaction is performed

# pooling of filtered OTUs: if pool is T, abundances of OTUs removed by 
# filtering are pooled and shown as "Other" in bar charts; does not apply
# to heat maps and MDS.
pool <- T 

# maximum number of OTUs allowed in stacked bar charts
# will be used to generate the OTU palette with randomcoloR
maxOTUcats <- 25
# maximum number of "species" for which prevalence and abundance is saved
topp <- 50
# if the number of "species" in data is lower, then it is going to be the 
# max number of species
# maximum number of "species" in box plots, heat maps and NMDS
# must be <topp
topn <-25
# max "samples" or sample categories for barplots and boxplots
max_samples <- 25
# max number of samples in the bonus barplot (the last chunk!)
topx <- 19

# logging the color scale in heat maps; set to T if you want the scale
# in log10(relabundance); set to F if you want to keep a linear scale
loghmscale <- T

# option for performing rarefaction analysis on the unfiltered matrix
dorareanalysis <- T

#########1#########2#########3#########4#########5#########6#########7#########8
# make a qualitative color palette
n <- maxOTUcats
rpalette <- distinctColorPalette(n)
names(rpalette) <- NULL
#########1#########2#########3#########4#########5#########6#########7#########8


```

The name of the data file used in this report is `r input_file_name`.  

# Methods.  
This is a short summary of the data and statistical methods used in this document.  
`r input_data$version`.  
The aggregation level for samples is `r input_data$sample_agg` (there are `r nrow(input_data$sample_metadata)` samples/sample groups). 
Here is the distribution of sample/sample groups by sample type (food or environment)

```{r table_s_type}
table(input_data$sample_metadata$s_type)
```

Here is the distribution of sample categories. xxxxx000x indicates environmental samples. The final letter indicates that the target was 16S RNA gene (d) or 16S RNA (r).  

```{r sample_types, echo = F}
kable(distinct(
  select(input_data$sample_metadata, llabel, foodId, L4, L6, nature, process, spoilage)
         ))
```

The aggregation level for taxa is `r input_data$tax_agg`. There are `r nrow(input_data$taxa_metadata)` identified at `r input_data$tax_agg` level or above, before filtering.  
Rarefaction, sample filtering and taxonomic and abundance/prevalence filtering are (optionally) performed as described in the following section.  
Rarefaction curves are and diversity indices (number of observed "species", Chao1, ACE) calculated using functions of the [vegan package](https://cran.r-project.org/web/packages/vegan/index.html).  
Bar and box plots for relative taxa abundance, configurations for sample/sample groups and taxa are produced using functions of package [ggplot2](https://ggplot2.tidyverse.org).  
Enhanced heatmaps (sample/sample groups vs taxa) are produced using functions of the package [gplots](https://cran.r-project.org/web/packages/gplots/index.html). Distance matrix is calculated using the Bray-Curtis distance calculated with functions of the package vegan. Clustering is performed with stats::hclust using the UPGMA method.  
Non Metric Multidimensional Scaling is performed using functions of the [vegan package](https://cran.r-project.org/web/packages/vegan/index.html). 
Analysis of food-bacteria networks as bipartite networks is performed using functions of the [bipartite package](https://cran.r-project.org/web/packages/bipartite/vignettes/Intro2bipartite.pdf).


# Preparatory steps.  

## Taxonomic and prevalence and abundance filtering.  

A few filtering steps will be performed depending on the options in the previous chunk.  
A prevalence and abundance plot will be generated and saved as applicable and a prevalence and abundance table of the top 50 OTUs will be saved and optionally printed.    
Your options for filtering are:  

* removeOther `r removeOther`  

* removeKonly `r removeKonly`  

* removeChloroplast `removeChloroplast`  

* removeMitochondria `r removeMitochondria`  

* removeEukaryota `r removeEukaryota`  

* filtersamples `r filtersamples` (if T samples with <`minsampleab` sequences will be filtered) 

* filterOTUs `r filterOTUs` (if T abundance filtering will be performed)  

* abtreshold `r abtreshold`  

* prev_filter `r prev_filter` (if T prevalence filtering will be performed)  

* prev_treshold `r prev_treshold` (as proportion of samples)  


```{r filtering, dpi = 96, echo = F}

#########1#########2#########3#########4#########5#########6#########7#########8
# Fix the sample_metadata -------------------------------------------------
#########1#########2#########3#########4#########5#########6#########7#########8
# keep a copy of sample_metadata
sample_metadata <- input_data$sample_metadata
row.names(sample_metadata) <- sample_metadata$label
sample_metadata_f <- sample_metadata # will be modified by sample filtering

# note that input_data$sample_agg can take values "sample" and "exp. code"


#########1#########2#########3#########4#########5#########6#########7#########8
# Create a "filtered" version of the OTU table -------------------------------

#########1#########2#########3#########4#########5#########6#########7#########8
tOTUm <- input_data$OTU_table
totseqs <- rowSums(tOTUm[complete.cases(tOTUm),])
OTUmatrixf <- tOTUm[complete.cases(tOTUm),]

# sample filter first
# optionally remove samples/sample groups with less than minsampleab sequences
# filtered samples will be also removed from the sample metadata table
# reset filtersamples if aggregation is exp. code
if(input_data$sample_agg == "exp. code") filtersamples <-F

if (filtersamples){
  samples_to_keep <- which(totseqs >= minsampleab)
  if(length(samples_to_keep) < nrow(OTUmatrixf)){
    OTUmatrixf <- OTUmatrixf[samples_to_keep,]
    totseqs <- rowSums(OTUmatrixf)
    keepMetadata <- which(row.names(sample_metadata) %in% names(samples_to_keep))
    sample_metadata_f <- sample_metadata[keepMetadata,] 
    }
  filtersamples_flag <- T
}

# optionally remove "Other", "Chloroplast", "Mitochondria" and "Eukaryota"
# and taxa with identification only at the level of Kingdom
if (removeOther) {
  OTUmatrixf <- OTUmatrixf[, colnames(OTUmatrixf)!= "Other"]
}
if (removeChloroplast){
  chl_labels <- input_data$taxa_metadata %>%
    dplyr::filter(label == "Chloroplast" | class == "Chloroplast") %>%
    pull(label) 
  OTUmatrixf <- OTUmatrixf[, -which(colnames(OTUmatrixf) %in% chl_labels)]
}
if (removeMitochondria){
  mit_labels <- input_data$taxa_metadata %>%
    dplyr::filter(label == "Mitochondria" | family == "Mitochondria") %>%
    pull(label)
  OTUmatrixf <- OTUmatrixf[, -which(colnames(OTUmatrixf) %in% mit_labels)]
}
if (removeEukaryota){
  euk_labels <- input_data$taxa_metadata %>%
    dplyr::filter(domain == "Eukaryota") %>%
    pull(label)
  if (length(euk_labels > 0)){
    OTUmatrixf <- OTUmatrixf[, -which(colnames(OTUmatrixf) %in% euk_labels)]
  }
}
if (removeKonly){
  Konly <- input_data$taxa_metadata %>%
    dplyr::filter(is.na(phylum)) %>%
    pull(label)
  OTUmatrixf <- OTUmatrixf[, -which(colnames(OTUmatrixf) %in% Konly)]
}


# optionally rarefy the samples with vegan::rrarefy()
if (rareoption){
  rarenn <- ifelse(raremin, 100*floor(min(totseqs)/100), raren)
  OTUmatrixf <- vegan::rrarefy(OTUmatrixf, rarenn)
  # drop colums with 0 sum
  OTUmatrixf <- OTUmatrixf[, colSums(OTUmatrixf)>0]
  OTUtokeep <- colnames(OTUmatrixf)
  rarefy_flag <- T
}

# optionally filter OTUs which are rare and/or have low prevalence

if (filterOTUs){
  OTUmatrixf_relab <- OTUmatrixf/rowSums(OTUmatrixf)
  maxrelab <- apply(OTUmatrixf_relab, 2, max)
  # OTU to keep (mar rel. abundance > abtreshold AND prevalence > prev_treshold)
  prevdf <- apply(X = OTUmatrixf,
                  MARGIN = 2,
                  FUN = function(x){sum(x > 0)})
  min_rel_ab <- apply(X = OTUmatrixf_relab,
                      MARGIN = 2,
                      FUN = function(x){min(x)})
  max_rel_ab <- apply(X = OTUmatrixf_relab,
                      MARGIN = 2,
                      FUN = function(x){max(x)})
  # Add taxonomy and total read counts to this data.frame
  prevdf <- data.frame(Prevalence = prevdf,
                       TotalAbundance = colSums(OTUmatrixf),
                       min_rel_ab = min_rel_ab,
                       max_rel_ab = max_rel_ab)
  prevdf <- prevdf %>% 
    rownames_to_column(var = "label") %>%
    left_join(., select(input_data$taxa_metadata, label, phylum:species))
  if(prev_filter){
    pass_prev_filter <- dplyr::filter(select(prevdf, label, Prevalence), 
                                      Prevalence > floor(nrow(sample_metadata)*prev_treshold)) %>%
      pull(label)
    OTUtokeep <- intersect(
      names(which(maxrelab >= abtreshold)),
      pass_prev_filter)
  } else {
    OTUtokeep <- names(which(maxrelab >= abtreshold))
  }
  prevdf <- prevdf  %>%
    mutate(relAbundance = TotalAbundance/sum(TotalAbundance), 
           pass_maxrelab_treshold = ifelse(label %in% OTUtokeep, "T", "F"))
  
  # make a plot
  
  # prevalence vs abundance graph
  
  # filter the OTUmatrix by abundance and prevalence 
  
  OTUmatrixf <- OTUmatrixf[, which(colnames(OTUmatrixf_relab) %in% OTUtokeep)]
  f_seq_ret <- round(sum(OTUmatrixf)/sum(tOTUm),4)
  title_text <- "Prevalence vs. abundance, by Phylum"
  subtitle_text <- paste("using the filters you retain ", length(OTUtokeep), 
                         " taxa (triangles) out of ", ncol(tOTUm), 
                         " (", f_seq_ret*100, "% of init. seqs.)", sep ="")

  # a prevalence and abundance plot
  prev_ab_plot <- ggplot(prevdf, aes(x = TotalAbundance, y = Prevalence / nrow(OTUmatrixf), 
                     shape = as.factor(pass_maxrelab_treshold), color = phylum)) +
    geom_point(size = 2, alpha = 0.7) +
    facet_wrap( ~ phylum) +
    geom_hline(yintercept = ifelse(prev_filter, prev_treshold, 0),
               alpha = 0.5,
               linetype = 2) +
    labs(x = "total abundance", y = "Prevalence [Frac. Samples]",
         shape = 'pass ab. treshold',
         title = title_text, subtitle = subtitle_text) +
    scale_x_log10() +
    scale_y_continuous(minor_breaks = seq(0, 1, 0.05)) +
    theme(legend.position = "none", plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 90))
  print(prev_ab_plot)

  filterOTU_flag <- T
  if(prev_filter) prev_filter_flag <- T
}
prevdf <- prevdf %>%
  mutate(relprev = Prevalence/nrow(OTUmatrixf)) %>%
  arrange(-relprev, - relAbundance)
filtOTU <- ncol(tOTUm)-ncol(OTUmatrixf)
# fix sample and taxa
sample_metadata_f <- sample_metadata_f %>%
  mutate_at(vars(llabel, s_type, L1, L4, L6, nature, process, spoilage, 
                 studyId, target1, target2), as.factor)
taxa_metadata_f <- input_data$taxa_metadata %>% 
  dplyr::filter(label %in% colnames(OTUmatrixf)) # maybe should create factors here

topp <- ifelse(topp<nrow(prevdf), topp, nrow(prevdf))

toppprev <- slice(prevdf,1:topp) %>% select(label, phylum, class, order, family, 
                                           genus, relAbundance, min_rel_ab, 
                                           max_rel_ab, relprev)
write_tsv(toppprev, str_c("file_name_prefix","topp.txt",sep="_"))

if(verbose_output) toppprev
```

The original abundance table has `r ncol(tOTUm)` taxa and `r nrow(tOTUm)` samples/sample groups.  
After filtering there are `r nlevels(sample_metadata$llabel)` llabel groups (these are combinations of FoodEx2 FoodId with further metadata on nature, process and spoilage), `r nlevels(sample_metadata_f$L1)` food groups, `r nlevels(sample_metadata_f$L4)` food subgroups.  
After filtering/rarefaction you have removed `r filtOTU` OTU out of `r ncol(tOTUm)`.  

## Create a palette for samples.  

Including the palettes for samples in some graphs is awkward and difficult to automate. Palettes will be generated and saved here.  


```{r sample_palette, dpi = 96, include = T, echo=FALSE}
#########1#########2#########3#########4#########5#########6#########7#########8
# Make palettes for samples -----------------------------------------------
# The script will determine if sample labels are llabels or sample ids, based  #
# on aggSample, loaded with the input data.                                    #
# If the number of L4 levels is <=15 L4 will be used for palettes.             #
# L1 will be used otherwise. To override this set overrides to T (unwise, may  #
# result in problems in legends).                                              #
#########1#########2#########3#########4#########5#########6#########7#########8
catsamples <- "L4"
maxslevels <- max(c(nlevels(sample_metadata_f$L1), 
                    nlevels(sample_metadata_f$L4)))
if(maxslevels>12) {
  lspalette <- distinctColorPalette(maxslevels)
  names(lspalette) <- NULL
}

if (!overrides){
  catsamples <- ifelse(nlevels(sample_metadata_f$L4)<=15,
                       "L4","L1")
}
samplenames <- data.frame(label = row.names(OTUmatrixf), stringsAsFactors = F)

cat("There are ", nrow(OTUmatrixf), " samples in the data set, belonging to", 
    "\n", nlevels(sample_metadata_f$L1), " food groups and ",
    nlevels(sample_metadata_f$L4), " subgroups.", "\n",
    catsamples, " will be used for palettes.", sep ="")

groupcolors <- inner_join(samplenames, select(sample_metadata_f, label, L1, L4))
ncolfoodg <- nlevels(groupcolors$L1)
ncolfoodsg <- nlevels(groupcolors$L4)
foodgpalette <- if(ncolfoodg<=12) {
  brewer.pal(ncolfoodg, "Paired")[1:ncolfoodg]
} else {
  distinctColorPalette(ncolfoodg)
}

foodsgpalette <- if(ncolfoodsg<=12) {
  brewer.pal(ncolfoodsg, "Paired")[1:ncolfoodsg]
} else {
  distinctColorPalette(ncolfoodsg)
}

foodgpalette <- data.frame(cbind(L1 = levels(groupcolors$L1),
                                 fgcolor = foodgpalette))

foodsgpalette <- data.frame(L4 = levels(groupcolors$L4),
                            fsgcolor = foodsgpalette)

# Merge the palettes with sample names and metadata
groupcolors <- merge(groupcolors, foodgpalette, by = "L1")
groupcolors <- merge(groupcolors, foodsgpalette, by = "L4")
groupcolors <- groupcolors %>% dplyr::arrange(label)
# Set the palette and colors and text for legends
if (catsamples  == "L1") {
  myspalette <- as.character(groupcolors$fgcolor)
  mystext <- as.character(foodgpalette$L1)
  myscolors <- as.character(foodgpalette$fgcolor)
} else {
  myspalette <- as.character(groupcolors$fsgcolor)
  mystext <- as.character(foodsgpalette$L4)
  myscolors <- as.character(foodsgpalette$fsgcolor) 
}
# Show the palette and plots a legend in a horizontal format
# It might be a good idea to save the legend graph
ltitle <- paste("Sample groups ", "(", catsamples, ", FoodEx2 class.)", sep = "")
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
legend("center", pch=15, legend = mystext, col = myscolors, 
       bty = "n",
       # ncol = if(length(mystext>10)) 2 else 1,
       title = ltitle)
if (savegraph) {
  par(pin = c(graphsizein,graphsizein))
  if (graphtype == "pdf") {
    pdf(file = paste(file_name, "fpal.pdf", sep = ""), width = graphsizein, 
        height = graphsizein, paper = "default")
  } else {
    tiff(filename = paste(file_name, "fpal.tif", sep = ""), 
         width = graphsizein, height = graphsizein, units = "in",
         res = graphresolution, compression = "none")
  }
  plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
  legend("center", pch=15, legend = mystext, col = myscolors, 
         bty = "n", 
         ncol = if(length(mystext>10)) 2 else 1,
         title = ltitle)
  par(opar)
  dev.off()
}
# Clean up (if you want to recreate a palette you have to run 221-306 again)    
rm(foodgpalette, foodsgpalette, ncolfoodg, ncolfoodsg, samplenames)
```

# Descriptive plots.  

These are a few descriptive plots which are usually shown in scientific papers on food microbiota.  
You should not overinterpret them.

## Rarefaction.  

Rarefaction is optionally performed using the following options: 

* rareoption `r rareoption`  (if T perform rarefaction)

* raremin `r raremin` (if raremin is T will rarefy to the closest hundred below the
minimum number of sequences, otherwise will rarefy to raren)  

* raren `r raren`  

* dorareanalysis `r dorareanalysis` (if T  rarefation analysis and calculation of diversity indices is performed)

This module also performs calculation of diversity indices and **may take very long** for large number of samples/sample groups.  

```{r rarefaction, dpi = 96, echo = F}
#########1#########2#########3#########4#########5#########6#########7#########8
# Rarefaction analysis and diversity indices (optional) -----------------------
#########1#########2#########3#########4#########5#########6#########7#########8
if (dorareanalysis){
  richness <- t(estimateR(tOTUm)) 
  richness <- as.data.frame(richness)
  write_tsv(richness, file = str_c(file_name_prefix, "rarecurve.pdf", sep = "_"))
  if(verbose_output) {
    richness
  } 
  rarecurve(tOTUm, step = 10, col = myspalette)
  if (savegraph) {
    par(pin = c(graphsizein,graphsizein))
    if (graphtype == "pdf") {
      pdf(file = paste(file_name, "rarecurve.pdf", sep = ""), width = graphsizein, 
          height = graphsizein, paper = "default")
    } else {
      tiff(filename = paste(file_name, "rarecurve.tif", sep = ""), 
           width = graphsizein, height = graphsizein, units = "in",
           res = graphresolution, compression = "none")
    }
    rarecurve(tOTUm, step = 10, col = myspalette)
    par(opar)
    dev.off()
  }
}

```


## Bar plots.  

This module generates bar plots at the genus, family and class level using rel. frequencies before filtering/rarefaction (if any). The plots are generated only if the number of categories is <=maxOTUcats. Note: this section will attempt to use a color brewer qualitative palette if the number of categories for the taxonomic level are <=12, otherwise it will use a default palette and difference in colors may be difficult to perceive.        

```{r bar_plots, dpi = 96, echo = FALSE}

# need the following because OTUmatrixf_relab is only created if filterOTUs is T

if(!exists("OTUmatrixf_relab")) OTUmatrixf_relab <- OTUmatrixf/rowSums(OTUmatrixf)
# column Other may be close to 0 if no taxa filtering is applied
if (pool){
  OTUmatrixf_relab_2 <- cbind(OTUmatrixf_relab,1-rowSums(OTUmatrixf_relab))
  colnames(OTUmatrixf_relab)[ncol(OTUmatrixf_relab)] <-"Other"
} else {
  OTUmatrixf_relab_2 <- OTUmatrixf_relab/rowSums(OTUmatrixf_relab)  
}


otm <- as.data.frame(OTUmatrixf_relab_2) %>% rownames_to_column(var = "source")
edge_table_filtered <- pivot_longer(otm, cols = 2:ncol(otm), names_to = "target", values_to = "weight")

# join taxonomic information and recode factors to move Other at the top
edge_table_filtered <- left_join(edge_table_filtered, 
                                  select(taxa_metadata_f, label, class:species), 
                                  by  = c("target" = "label")) %>%
  dplyr::filter(weight >0)

# setting flags for bar plots
bpgenusf <- F
bpfamilyf <- F
bpclassf <- F

if (input_data$tax_agg != "class"){
  if (input_data$tax_agg != "family") {
    # Genus level
    e_table_f_agg <- edge_table_filtered %>% 
      group_by(source, genus) %>%
      dplyr::summarise(weight = sum(weight)) %>%
      mutate(genus = ifelse(is.na(genus), "Other", genus))
    taxa_levels <- unique(e_table_f_agg$genus)
    if ("Other" %in% taxa_levels) {
      taxa_levels <- c("Other",setdiff(taxa_levels,"Other"))
    }
    e_table_f_agg$genus <- factor(e_table_f_agg$genus, levels = taxa_levels) 
    n_taxa <- length(levels(e_table_f_agg$genus))
    if (n_taxa<=maxOTUcats) {
      bpgenusf <- T
      sbplot <- ggplot(data = e_table_f_agg, aes(x = source, y= weight, fill = genus))
      if (n_taxa>=12) {
        bpgenus <- sbplot + geom_col(position = "fill") + 
          scale_fill_manual(values = rpalette[1:n_taxa]) +
          labs(title = "Relative abundance, genus",
               x= "Samples/Sample groups",
               y= "Relative abundance") +
          theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
                panel.background= element_rect(fill = "white"),
                plot.title = element_text(hjust = 0.5))
        print(bpgenus)
      } else {
        bpgenus <- sbplot + geom_col(position = "fill") + 
          labs(title = "Relative abundance, genus",
               x= "Samples/Sample groups",
               y= "Relative abundance") +
          scale_fill_brewer(type = "qual", palette = "Paired") +
          theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
                panel.background= element_rect(fill = "white"),
                plot.title = element_text(hjust = 0.5))
        print(bpgenus)
      }
    } else {
      # con shiny non deve restituire un messaggio ma un grafico
      # o devo mettere un campo output con un messaggio
      cat("Too many genera, genus bar chart aborted...","\n","\n")
    }
  }

  # Family level
  e_table_f_agg <- edge_table_filtered %>% 
    group_by(source, family) %>%
    dplyr::summarise(weight = sum(weight)) %>%
    mutate(family = ifelse(is.na(family), "Other", family))
  taxa_levels <- unique(e_table_f_agg$family)
  if ("Other" %in% taxa_levels) {
    taxa_levels <- c("Other",setdiff(taxa_levels,"Other"))
  }
  e_table_f_agg$family <- factor(e_table_f_agg$family, levels = taxa_levels) 
  n_taxa <- length(levels(e_table_f_agg$family))  
  
  if (n_taxa <= maxOTUcats) {
    bpfamilyf <- T
    sbplot <- ggplot(data = e_table_f_agg, aes(x = source, y= weight, fill = family))
    if (nlevels(e_table_f_agg$Family)>=12) {
      bpfamily <- sbplot + geom_col(position = "fill") + 
        scale_fill_manual(values = rpalette[1:n_taxa]) +
        labs(title = "Relative abundance, Family",
             x= "Samples/Sample groups",
             y= "Relative abundance") +
        theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
              panel.background= element_rect(fill = "white"),
              plot.title = element_text(hjust = 0.5))
      bpfamily
    } else {
      bpfamily <- sbplot + geom_col(position = "fill") + 
        labs(title = "Relative abundance, Family",
             x= "Samples/Sample groups",
             y= "Relative abundance") +
        scale_fill_brewer(type = "qual", palette = "Paired") +
        theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
              panel.background= element_rect(fill = "white"),
              plot.title = element_text(hjust = 0.5))
      bpfamily
    }
  } else {
    cat("Too many families, family bar chart aborted...","\n","\n")
  }
} else {
  cat("OTU aggregated at the Class level, Genus and Family plots skipped")
}

# Class level
e_table_f_agg <- edge_table_filtered %>% 
  group_by(source, class) %>%
  dplyr::summarise(weight = sum(weight)) %>%
  mutate(class = ifelse(is.na(class), "Other", class))
taxa_levels <- unique(e_table_f_agg$class)
if ("Other" %in% taxa_levels) {
  taxa_levels <- c("Other",setdiff(taxa_levels,"Other"))
}
e_table_f_agg$class <- factor(e_table_f_agg$class, levels = taxa_levels) 
n_taxa <- length(levels(e_table_f_agg$class))  
sbplot <- ggplot(data = e_table_f_agg, aes(x = source, y= weight, fill = class))
if (n_taxa<=maxOTUcats){
  bpclassf <- T
  if (n_taxa>=12) {
    bpclass <- sbplot + geom_col(position = "fill") + 
      scale_fill_manual(values = rpalette[1:n_taxa]) +
      labs(title = "Relative abundance, Class",
           x= "Samples/Sample groups",
           y= "Relative abundance") +
      theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
            panel.background= element_rect(fill = "white"),
            plot.title = element_text(hjust = 0.5))
    bpclass
  } else {
    bpclass <- sbplot + geom_col(position = "fill") + 
      labs(title = "Relative abundance, Class",
           x= "Samples/Sample groups",
           y= "Relative abundance") +
      scale_fill_brewer(type = "qual", palette = "Paired") +
      theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
            panel.background= element_rect(fill = "white"),
            plot.title = element_text(hjust = 0.5))
    bpclass
  }
} else {
  cat("Too many classes, class bar chart aborted...","\n","\n")
}

# saving barplots
if (savegraph) {
  if (bpgenusf){
    ggsave(filename = str_c(file_name_prefix, "bp","genus",gfileext),  
           plot = bpgenus, width = 7, height = 5, dpi = graphresolution)
  }  
  if (bpfamilyf){
    ggsave(filename = str_c(file_name_prefix, "bp","family",gfileext),  
           plot = bpfamily, width = 7, height = 5, dpi = graphresolution)
  }
  if (bpclassf){
    ggsave(filename = str_c(file_name_prefix,  "bp","class",gfileext),  
           plot = bpclass, width = 7, height = 5, dpi = graphresolution)
  }
}

```

## Box plots.  

This module plots and saves box plots for the distribution of the 25 most abundant and prevalent taxa (genus, family or class, depending of taxonomic aggregation in the input file).
Beware: if you aggregate at the llabel (exp.code), L1, L4 or L6 level, depending on your selections of samples you may be aggregating samples with very different characteristics. Therefore: choose wisely your subset of samples in ShinyFMBN.  

```{r box_plots, dpi = 96, echo = F}

# box plots for the n most abundant taxa -------------------------------

# I am selecting the top n most abundant and prevalent taxa (genera, families, classes,
# depending on taxonomic aggregation in the input file)
# with some exceptions all further analysis will be performed on these taxa

topntaxa <- dplyr::filter(toppprev, !is.na(get(input_data$tax_agg)))

topn <- ifelse(topn<nrow(topntaxa), topn, nrow(topntaxa))

topntaxa <- topntaxa %>%
  slice(1:topn) %>%
  pull(label)

edge_table_filtered <- edge_table_filtered %>%
  dplyr::filter(target %in% topntaxa)

# now join the metadata for samples
sample_data <- sample_metadata_f %>% 
  select(label, studyId, llabel, foodId, L1, L4, L6)
edge_table_boxplot <- left_join(edge_table_filtered, 
                                 sample_data, 
                                 by  = c("source" = "label"))

# get the variable to use on x axis

# it will be the lowest aggregation level with <= max_samples levels

sample_nlevels <- sample_data %>%
  summarize(across(.fns = n_distinct)) %>%
  select(llabel, foodId, L6, L4, L1)

xaxisvariable <- colnames(sample_nlevels)[which(sample_nlevels[1,]<=max_samples)[1]]

# now plot
topnboxplot <- ggplot(edge_table_boxplot, mapping = aes(get(xaxisvariable), weight))
topnboxplot +
  geom_boxplot() +
  geom_jitter(alpha = 0.2) +
  facet_wrap(~target) +
  labs(x= xaxisvariable, y= "rel.ab.") +
  scale_y_log10(breaks = c(1E-5, 1E-4, 1E-3, 1E-2, 1E-1, 1)) +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        strip.text = element_text(size = 6))
ggsave(filename = str_c(file_name_prefix, "bxp","topntaxa",gfileext),  
       width = 9, height = 7, dpi = graphresolution)

```

## Heat maps.

This module creates a heat map with dendrograms (Bray-Curtis is used as a distance and UPGMA for agglomeration) for both samples and taxa. With many taxa and samples/sample groups the output might not plot very well.  
  
The aggregation level for taxa is `r input_data$tax_agg`.  
There are `r ncol(OTUmatrixf)` taxa in this set. Only `r topn` will be used in the analysis.  

First, I am going to create a palette for samples. This can be merged in the heat map to make a publication quality figure.  

```{r heatmaps_1, dpi = 96, echo = F, eval = T}
#########1#########2#########3#########4#########5#########6#########7#########8
# Heatmaps ----------------------------------------------------------------
#########1#########2#########3#########4#########5#########6#########7#########8
# create a palette of 100 colours for OTU abundance
colscale <- colorRampPalette(c("lightyellow", "orange", "brown"), 
                             space = "rgb")(100)
# remove the columns with the pooled OTUs (if any) from the filtered matrix
# of relative frequencies
OTUmatrixf_relab_hm <- OTUmatrixf_relab[, topntaxa]
if (any(colnames(OTUmatrixf_relab_hm) == "Other")){
  OTUmatrixf_relab_hm <- OTUmatrixf_relab_hm[, -which(colnames(OTUmatrixf_relab_hm) == "Other")]
}

# Create palette for OTUs. See above for instructions to override defaults
# this should be transformed into a function
ET3 <- taxa_metadata_f %>%
  dplyr::filter(label %in% colnames(OTUmatrixf_relab_hm))
# must fill the NAs with info from higher taxa
ET3 <- ET3 %>% 
  mutate(domain = ifelse(is.na(domain),"Other", domain)) %>%
  mutate(phylum = ifelse(is.na(phylum), domain, phylum)) %>%
  mutate(class = ifelse(is.na(class), phylum, class)) %>%
  mutate(order = ifelse(is.na(order), class, order)) %>%
  mutate(family = ifelse(is.na(family), order, family))

ET3$class <- as.factor(ET3$class)
if (input_data$tax_agg == "class"){
  ET3$family <- ET3$class
} else {
  ET3$family <- as.factor(ET3$family)
}
ncolsfamily <- nlevels(ET3$family)
ncolsclass <- nlevels(ET3$class)
familypalette <- if(ncolsfamily<=12) {
  brewer.pal(ncolsfamily, "Set3")[1:ncolsfamily]
} else {
  distinctColorPalette(ncolsfamily)
}
classpalette <- if(ncolsclass<=12) {
  brewer.pal(ncolsclass, "Set3")[1:ncolsclass]
} else {
  distinctColorPalette(ncolsclass)
}

# I am selecting label, class, family

OTUcolors <- ET3[, c(1, 4, 6)]

# incolla qui
fcolors <- data.frame(family = levels(OTUcolors$family),
                      fcolor = familypalette)
ccolors <- data.frame(class = levels(OTUcolors$class),
                      ccolor = classpalette)

# Merge the palettes with label and lineage info
OTUcolors <- merge(OTUcolors, ccolors, by = "class")
OTUcolors <- merge(OTUcolors, fcolors, by = "family")
OTUcolors <- arrange(OTUcolors, label)
# Provide summary info, set the palette to use
catOTUs <- "class"
familystring <-"."
if (input_data$tax_agg != "class"){
  catOTUs <- "family"
  familystring <- paste(" and ", nlevels(OTUcolors$family), 
                        " families.",sep = "")
  if (!overrideOTU) {
    catOTUs <- ifelse(nlevels(OTUcolors$family)<=15,
                      "family","class")
  }
}

if (catOTUs == "class") {
  myOTUpalette <- as.character(OTUcolors$ccolor)
  myOTUtext <- as.character(ccolors$class)
  myOTUcolors <- as.character(ccolors$ccolor)
} else {
  myOTUpalette <- as.character(OTUcolors$fcolor)
  myOTUtext <- as.character(fcolors$family)
  myOTUcolors <- as.character(fcolors$fcolor)
}
# Show the palette and plot a legend in a horizontal format. It might be a good
# idea to save the palette
par(opar)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
legend("center", pch=15, legend = myOTUtext, y.intersp = 0.8,
       col = myOTUcolors, bty = "n", title = catOTUs,
       ncol = 1)
if (savegraph) {
  if (graphtype == "pdf") {
    pdf(file = paste(file_name, "hmOTUpal.pdf", sep = ""), width = graphsizein, 
        height = graphsizein, paper = "default")
  } else {
    tiff(filename = paste(file_name, "hmOTUpal.tif", sep = ""), 
         width = graphsizein, height = graphsizein, units = "in",
         res = graphresolution, compression = "none")
  }
  plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
  legend("center", pch=15, legend = myOTUtext, y.intersp = 0.8,
         col = myOTUcolors, bty = "n", title = catOTUs,
         ncol = if(length(myOTUtext>10)) 2 else 1)
  dev.off()
}
```

Now I am going to create a heatmap. You can change the way the abundance scale is shown (log sequences or number of sequences) in the options chunk.

```{r heatmap_2, dpi = 96, echo =F}
# calculate distance matrices and dendrograms
sample.dist <- vegdist(OTUmatrixf_relab_hm, method = "bray")
# may generate warnings
sample.clus <- hclust(sample.dist, "aver")
OTU.dist <- vegdist(t(OTUmatrixf_relab_hm), method = "bray")
OTU.clus <- hclust(OTU.dist, "aver")
# may generate warnings: it is probably related to the order packages are loaded
hm <- OTUmatrixf_relab_hm
keyscale <- "rel. abundance"
if (loghmscale) {
  # lbound gives a default to 0 abundances using max number of seqs per sample
  lbound <- 10^(-ceiling(log10(max(rowSums(tOTUm)))))
  hm <- aaply(hm, c(1,2), 
              function(x,minprop) log10(x+minprop),minprop=lbound)
  keyscale <- "log10(rel.abundance)"
}

# heat map with legend for abundance levels, margins, lhei, lwid, srtCol, 
# offsetRow and offsetCol may require tinkering.
# Size temporarily reset for saving
heatmap.2(hm, 
          Rowv = as.dendrogram(sample.clus), 
          Colv = as.dendrogram(OTU.clus),
          srtCol = 30,
          col = colscale,
          breaks = 101,
          symbreaks = F,
          ColSideColors = myOTUpalette,
          RowSideColors = myspalette,
          margins = c(7,11),
          trace = "both", density.info = "none",
          tracecol = "orange1",
          lhei = c(2.5,7.5),
          lwid = c(2.5,7.5),
          offsetRow = 0.5,
          offsetCol = 0.5,
          key.title = "NA",
          key.xlab = keyscale,
          keysize = 0.1,
          symkey = F
)
if (savegraph) {
  if (graphtype == "pdf") {
    pdf(file = paste(file_name, "hm2.pdf", sep = ""), width = 10, 
        height = 7, paper = "a4r")
  } else {
    tiff(filename = paste(file_name, "hm2.tif", sep = ""), 
         width = 10, height = 7, units = "in",
         res = graphresolution, compression = "none")
  }
  heatmap.2(hm, 
            Rowv = as.dendrogram(sample.clus), 
            Colv = as.dendrogram(OTU.clus),
            srtCol = 30,
            col = colscale,
            breaks = 101,
            symbreaks = F,
            ColSideColors = myOTUpalette,
            RowSideColors = myspalette,
            margins = c(7,11),
            trace = "both", density.info = "none",
            tracecol = "orange1",
            lhei = c(2.5,7.5),
            lwid = c(2.5,7.5),
            offsetRow = 0.5,
            offsetCol = 0.5,
            key.title = "NA",
            key.xlab = keyscale,
            keysize = 0.1,
            symkey = F
  )
  dev.off()  
}
par(opar)


```

## Multidimentional scaling with Vegan.  

This module performs Multidimensional Scaling on the filtered data. The graphs which are produced depend on the verbose_output option.  With high number of taxa and sample/sample groups the graphs can be difficult to interpret. Filter wisely!

```{r NMDS, echo = F, dpi = 96}
# NMDS with vegan package using Bray-Curtis distance as default
# using OTUmatrixf (absolute abundances) works usually better, but triggers
# the autotransform option in metaMDS; if you want you can use relative
# abundances (use OTUmatrixf3)
# filtering OTUmatrixf (removing samples)

samples_2_keep <- which(row.names(OTUmatrixf) %in% groupcolors$label)
MDSall <- metaMDS(OTUmatrixf[samples_2_keep,colnames(OTUmatrixf_relab_hm)], trymax = 50)
MDSall
stressplot(MDSall)
plot(MDSall, type = "t")
# get proper plots using ggplot2
# make dataframes, add metadata for row names, sort to use palettes
speciescoord <- as.data.frame(MDSall$species)
speciescoord <- speciescoord[order(row.names(speciescoord)),] %>%
  rownames_to_column("label") %>%
  left_join(OTUcolors)
speciescoord$olabel <- OTUcolors[,which(colnames(OTUcolors)==
                                          catOTUs)]

samplecoord <-as.data.frame(MDSall$points)
samplecoord <- samplecoord[order(row.names(samplecoord)),]
samplecoord$slabel <- groupcolors[,which(colnames(groupcolors)==
                                           catsamples)]
rangex <- max(c(max(samplecoord$MDS1),max(speciescoord$MDS1)))
maxx <- rangex
minx <- min(min(samplecoord$MDS1), min(speciescoord$MDS1))
minx <- if_else(abs(minx)-abs(trunc(minx)) < 0.5, trunc(minx)-0.5,trunc(minx)-1)
maxx <- if_else(abs(maxx)-abs(trunc(maxx)) < 0.5, trunc(maxx)+0.5,trunc(maxx)+1)

rangey <- max(c(max(samplecoord$MDS2),max(speciescoord$MDS2)))
miny <- min(min(samplecoord$MDS2), min(speciescoord$MDS2))
miny <- if_else(abs(miny)-abs(trunc(miny)) < 0.5, trunc(miny)-0.5, trunc(miny)-1)
maxy <- rangey
maxy <- if_else(abs(maxy)-abs(trunc(maxy)) < 0.5, trunc(maxy)+0.5,trunc(maxy)+1)
# get the group with less than 12 levels, if any
sample_nlevels_MDS <- sample_data %>%
  summarize(across(.fns = n_distinct)) %>%
  select(L6, L4, L1)

colorv_MDS <- colnames(sample_nlevels_MDS)[which(sample_nlevels[1,]<=max_samples)[1]]

# sample MDS plot.
MDSsampleplot <- ggplot(data = samplecoord, aes(x = MDS1, y= MDS2))
# may be use ggrepel
MDSsampleplot + geom_point(aes(colour = str_wrap(slabel,20))) + 
  scale_color_manual(values = myscolors) +
  scale_x_continuous(limits = c(minx, maxx), breaks = seq(minx, maxx,0.1)) +
  scale_y_continuous(limits = c(miny, maxy), breaks = seq(miny, maxy, 0.1)) +
  labs(title = "MDS, samples",
       x= "dim(1)",
       y= "dim(2)",
       colour = catsamples) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
# saving sample metadata
write_tsv(sample_metadata_f, str_c(file_name_prefix, "sample_metadata.txt", 
                                   sep = "_"))

samplecoord_2 <- samplecoord %>%
  rownames_to_column(var = "label") %>%
  left_join(.,select(sample_metadata_f, label, L1:L6))

# need to change a variable name
samplecoord_2 <- samplecoord_2 %>% rename(llabel = label)
MDSsampleplot_2 <- ggplot(data = samplecoord_2, aes(x = MDS1, y= MDS2))

if(sample_nlevels_MDS[1,colorv_MDS]<=12){
  MDSsampleplot_2 + 
    geom_point(aes(colour = str_wrap(get(colorv_MDS),20))) + 
    geom_text_repel(mapping = aes(label = llabel), 
                    size = I(2.0), alpha = I(0.6), max.overlaps = 20) + 
    scale_color_brewer(type = "qual", palette = "Paired") +
    scale_x_continuous(limits = c(minx, maxx), breaks = seq(minx, maxx,0.1)) +
    scale_y_continuous(limits = c(miny, maxy), breaks = seq(miny, maxy, 0.1)) +
    labs(title = "MDS, samples",
         x= "dim(1)",
         y= "dim(2)",
         colour = colorv_MDS) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
} else{
  MDSsampleplot_2 + 
    geom_point(aes(colour = str_wrap(get(colorv_MDS),20))) + 
    geom_text_repel(mapping = aes(label = llabel), 
                    size = I(2.0), alpha = I(0.6), max.overlaps = 20) +
    scale_color_manual(values = rpalette) +
    scale_x_continuous(limits = c(minx, maxx), breaks = seq(minx, maxx,0.1)) +
    scale_y_continuous(limits = c(miny, maxy), breaks = seq(miny, maxy, 0.1)) +
    labs(title = "MDS, samples",
         x= "dim(1)",
         y= "dim(2)",
         colour = colorv_MDS) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))  
}


if (savegraph) {
  ggsave(filename =str_c(file_name_prefix, "_MDSsamples",gfileext), 
         width = 7, height = 5, dpi = graphresolution)
}

# a small change
speciescoord <- speciescoord %>% rename(llabel = label)

# species MDS plot. 
MDSOTUplot <- ggplot(data = speciescoord, aes(x = MDS1, y= MDS2))
MDSOTUplot + geom_point(aes(colour = olabel)) + 
  geom_text_repel(mapping= aes(label = llabel), 
                  size = 2.0, alpha = 0.6, max.overlaps = 20) +
  scale_color_manual(values = myOTUcolors) +
  scale_x_continuous(limits = c(minx,maxx), breaks = seq(minx,maxx,0.5)) +
  scale_y_continuous(limits = c(miny,maxy), breaks = seq(miny,maxy,0.5)) +
  labs(title = "Non-metric MDS, OTUs",
       x= "dim(1)",
       y= "dim(2)",
       colour = catOTUs) +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))
if (savegraph) {
  ggsave(filename = str_c(file_name_prefix, "_MDSspecies", gfileext), 
         width = 7, height = 5, dpi = graphresolution)
}

# biplot 
MDSsampleplot + 
  geom_point(aes(colour = slabel)) + 
  geom_text_repel(label = row.names(samplecoord), 
                  size = 3, 
                  color = "red", alpha = 0.6, max.overlaps = 20) +
  geom_text_repel(data = speciescoord, aes(x= MDS1, y= MDS2, label = llabel),
                  size = I(2.5), alpha = I(0.6), max.overlaps = 20) +
  scale_color_manual(values = myscolors) +
  scale_x_continuous(limits = c(minx,maxx), breaks = seq(minx,maxx,0.5)) +
  scale_y_continuous(limits = c(miny,maxy), breaks = seq(miny,maxy,0.5)) +
  labs(x= "dim(1)",
       y= "dim(2)",
       colour = catsamples) +
  theme_bw() + 
  theme(legend.key.size = unit(0.1, "in"), 
        legend.text = element_text(size = 6))

if (savegraph) {
  ggsave(filename = str_c(file_name_prefix, "_MDSbp",gfileext), 
         width = 7, height = 5, dpi = graphresolution)
}
```



# Bipartite analysis.  

This group of chunks performs a few statistical and graphical analyses which are appropriate for bipartite networks. Most of these were developed for pollinator networks, but I think that module node degree distribution, nodule detection and calculation of node and network indices may be interesting for the characterization of food-bacteria networks. The analysis is only performed  if the aggregation level of the samples is exp. code (i.e. samples are aggregated before saving with a combination of food code, nature, treatment, spoilage/fermentation and gene target fields; check the specifications for FoodMicrobionet tables to learn more).

## Degree distribution.  

Degree distribution for both upper (taxa) and lower (food groups) level may give an idea on the occurrence of scale-free, small world networks (power degree or truncated power degree distribution), in which a few nodes (hubs) have a high degree (occur in several foods for taxa, are colonized by a large number of different taxa for food samples) rather than a Poisson distribution which is characteristic of random graphs.
Degree distirbution is first calculated for the whole dataset (only Chloroplasts and Mitochondia are removed) and then after abundance and prevalence filtering.  
**Warning**: some steps are slow and memory and cpu intensive, be patient.  

```{r degree_distr_all, dpi = 96, echo = F}

if(input_data$sample_agg == "exp. code"){
  OTUmatrixbip <- tOTUm[complete.cases(tOTUm),]
  
  # remove "Other" and "Chloroplast"
  OTUmatrixbip <- OTUmatrixbip[, colnames(OTUmatrixbip)!= "Other"]
  OTUmatrixbip <- OTUmatrixbip[, colnames(OTUmatrixbip)!= "Chloroplast"]
  
  OTUdd <- as.data.frame(degreedistr(OTUmatrixbip, level = "higher", 
                                     plot.it = FALSE))
  degreedistr(OTUmatrixbip, level = "higher")
  Sampledd <- as.data.frame(degreedistr(OTUmatrixbip, level = "lower", 
                                        plot.it = FALSE))
  degreedistr(OTUmatrixbip, level = "lower")
}  

```

## Filtering, palettes.  

Further preliminary filtering (abundance only) and rarefaction (so that all sample groups have the same number of sequences) steps are performed and the palettes are generated ex novo.  

```{r filt_palette_bip, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){
  # remove samples is the sample filter was used
  if (filtersamples_flag){
    OTUmatrixbip <- OTUmatrixbip[samples_to_keep,]
  }
  
  OTUmatrixbip2 <- OTUmatrixbip/rowSums(OTUmatrixbip)
  maxrelabbip <- apply(OTUmatrixbip2, 2, max)
  OTUtokeepbip <- names(which(maxrelabbip >= abtreshold))
  OTUmatrixbip <- OTUmatrixbip[, which(colnames(OTUmatrixbip2) %in% OTUtokeepbip)]
  totseqsbip <- rowSums(OTUmatrixbip)
  rarennbip <- ifelse(raremin, 100*floor(min(totseqsbip)/100), raren)
  OTUmatrixbip <- vegan::rrarefy(OTUmatrixbip, rarennbip)
  rarefy_flag <- T
  OTUmatrixbip <- OTUmatrixbip[,colSums(OTUmatrixbip)>0]
  OTUtokeepbip <- colnames(OTUmatrixbip)
  filtOTUbip <- ncol(tOTUm)-ncol(OTUmatrixbip)
  
  # prints a summary
  
  cat("The original OTU/taxa abundance table has", ncol(tOTUm), "OTUs/taxa and ", 
      nrow(tOTUm), "samples/sample groups.", "\n", "\n", sep = " ")
  
  cat("After filtering there are", "\n", n_distinct(sample_metadata$llabel), 
      "llabel groups", "\n", sep = " ")
  cat(n_distinct(sample_metadata$L1), "food groups", "\n", sep = " ")
  cat(n_distinct(sample_metadata$L4), 
      "food subgroups", "\n", sep = " ")
  
  cat("After filtering/rarefaction you have removed", filtOTU, "OTU/TAXA out of", 
      ncol(tOTUm), "\n", "\n", sep = " ")
  
  #########1#########2#########3#########4#########5#########6#########7#########8
  # Rebuild palette for OTUs: palettes are made for family and class. Family is  #
  # is used if number of families <=15, otherwise class is used. To override     # 
  # this set overrideOTU <- T in line 74 (may result in problems in legends)     #
  #########1#########2#########3#########4#########5#########6#########7#########8
  taxa_metadata_f_bip <- input_data$taxa_metadata %>% 
    dplyr::filter(label %in% colnames(OTUmatrixbip)) # maybe should create factors here
  ET4 <- taxa_metadata_f_bip %>%
    dplyr::filter(label %in% colnames(OTUmatrixbip))
  ET4$class <- as.factor(ET4$class)
  if (input_data$tax_agg == "class"){
    ET4$family <- ET4$class
  } else {
    ET4$family <- as.factor(ET4$family)
  }
  ncolsfamily <- nlevels(ET4$family)
  ncolsclass <- nlevels(ET4$class)
  familypalette <- if(ncolsfamily<=12) {
    brewer.pal(ncolsfamily, "Set3")[1:ncolsfamily]
  } else {
    distinctColorPalette(ncolsfamily)
  }
  classpalette <- if(ncolsclass<=12) {
    brewer.pal(ncolsclass, "Set3")[1:ncolsclass]
  } else {
    distinctColorPalette(ncolsclass)
  }
  OTUcolors <- select(ET4,label, class, family)
  fcolors <- data.frame(family = levels(OTUcolors$family),
                        fcolor = familypalette)
  ccolors <- data.frame(class = levels(OTUcolors$class),
                        ccolor = classpalette)
  
  # Merge the palettes with OTUID and lineage info
  OTUcolors <- merge(OTUcolors, ccolors, by = "class")
  OTUcolors <- merge(OTUcolors, fcolors, by = "family")
  OTUcolors <- arrange(OTUcolors, label)
  # Provide summary info, set the palette to use
  catOTUs <- "class"
  familystring <-"."
  if (input_data$tax_agg != "class"){
    catOTUs <- "family"
    familystring <- paste(" and ", nlevels(OTUcolors$family), 
                          " families.",sep = "")
    if (!overrideOTU) {
      catOTUs <- ifelse(nlevels(OTUcolors$family)<=15,
                        "family","class")
    }
  }
  
  cat("The aggregation level for OTUs is ", input_data$tax_agg, "\n", 
      "There are ", ncol(OTUmatrixf), " OTU in this set.", "\n",
      "They belong to ", nlevels(OTUcolors$class), " classes",
      familystring, "\n", "The category used for OTU palettes is ", catOTUs, ".", 
      sep="")
  
  if (catOTUs == "class") {
    myOTUpalettebip <- as.character(OTUcolors$ccolor)
    myOTUtextbip <- as.character(ccolors$class)
    myOTUcolorsbip <- as.character(ccolors$ccolor)
  } else {
    myOTUpalettebip <- as.character(OTUcolors$fcolor)
    myOTUtextbip <- as.character(fcolors$family)
    myOTUcolorsbip <- as.character(fcolors$fcolor)
  }
  
  # Show the palette and plot a legend in a horizontal format. It might be a good
  # idea to save the palette graph
  plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
  legend("center", pch=15, legend = myOTUtextbip, y.intersp = 0.8,
         col = myOTUcolorsbip, bty = "n", 
         ncol = if(length(myOTUtextbip)>10) 2 else 1,
         title = catOTUs)
  if (savegraph) {
    if (graphtype == "pdf") {
      pdf(file = paste(file_name, "bipOTUpal.pdf", sep = ""), width = graphsizein, 
          height = graphsizein, paper = "default")
    } else {
      tiff(filename = paste(file_name, "bipOTUpal.tif", sep = ""), 
           width = graphsizein, height = graphsizein, units = "in",
           res = graphresolution, compression = "none")
    }
    plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n", ann = FALSE)
    legend("center", pch=15, legend = myOTUtextbip, y.intersp = 0.8,
           col = myOTUcolorsbip, bty = "n", 
           ncol = if(length(myOTUtextbip)>10) 2 else 1,
           title = catOTUs)
    dev.off()
  }
  
  # Clean up (if you want to recreate a palette you have to run the code above again)    
  rm(ccolors, fcolors, classpalette, familypalette, ncolsclass,
     ncolsfamily, familystring)
}
```

## Plot the filtered network.  

The bipartite network is plotted: adjusting the graph parameters is tricky and very difficult to automate, but the saved graph should be fine. However, avoid using too many taxa and samples/sample groups.  

```{r plotting_web, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){
  #########1#########2#########3#########4#########5#########6#########7#########8
  # Plot the filtered web. adjust y.lim and text.width to fit labels if needed.
  # The legend may need some tinkering. Adjust y.lim and twidths to fit labels 
  # and legend if needed. The section has been tested with par(pin=c(13.5,6)).
  # In Rstudio you need to adjust the size of the plot pane.
  #########1#########2#########3#########4#########5#########6#########7#########8
  ncol_top <- case_when(
    length(myOTUtextbip) <=5 ~ 1,
    length(myOTUtextbip) >5 && length(myOTUtextbip) <=10 ~ 2,
    length(myOTUtextbip) >10 && length(myOTUtextbip) <=15 ~ 3,
    length(myOTUtextbip) >15 ~4
  )
  ncol_bottom = case_when(
    length(mystext) <=5 ~ 1,
    length(mystext) >5 && length(mystext) <=10 ~ 2,
    length(mystext) >10 && length(mystext) <=15 ~ 3,
    length(mystext) >15 ~4
  )
  plotweb(OTUmatrixbip, text.rot = 90, y.lim=c(0,2.5), col.high = myOTUpalettebip,
          col.low = myspalette, low.y = 0.8)
  twidthOTU <- max(strwidth(myOTUtextbip))*0.8
  sltitle <- ifelse(catsamples == "L1", "FoodEx2 class L1", "FoodEx2 class L4")
  legend("top", xjust = 0.5, yjust = 0, legend = myOTUtextbip, 
         col = myOTUcolorsbip, bty = "n", title = catOTUs, 
         pch = 15, cex = 0.75, ncol = ncol_top, y.intersp = 0.6, text.width = twidthOTU)
  twidths <- max(strwidth(mystext))*0.6
  legend("bottom", xjust = 0.5, yjust = 1, 
         legend = mystext, 
         col = myscolors, bty = "n", 
         title = sltitle, y.intersp = 0.6,
         pch = 15, cex = 0.75, ncol = ncol_bottom, text.width = twidths)
  if (savegraph) {
    if (graphtype == "pdf") {
      pdf(file = paste(file_name, "bipnet.pdf", sep = ""), width = graphsizein*1.2, 
          height = graphsizein, paper = "default")
    } else {
      tiff(filename = paste(file_name, "bipnet.tif", sep = ""), 
           width = graphsizein*1.2, height = graphsizein, units = "in",
           res = graphresolution, compression = "none")
    }
    plotweb(OTUmatrixbip, text.rot = 90, y.lim=c(0,2.5), col.high = myOTUpalettebip,
            col.low = myspalette, low.y = 0.8)
    twidthOTU <- max(strwidth(myOTUtextbip))*0.8
    sltitle <- ifelse(catsamples == "L1", "FoodEx2 class L1", "FoodEx2 class L4")
    legend("top", xjust = 0.5, yjust = 0, legend = myOTUtextbip, 
           col = myOTUcolorsbip, bty = "n", title = catOTUs, 
           pch = 15, cex = 0.75, ncol = ncol_top, y.intersp = 0.6, text.width = twidthOTU)
    twidths <- max(strwidth(mystext))*0.6
    legend("bottom", xjust = 0.5, yjust = 1, 
           legend = mystext, 
           col = myscolors, bty = "n", 
           title = sltitle, y.intersp = 0.6,
           pch = 15, cex = 0.75, ncol = ncol_bottom, text.width = twidths)
    dev.off()
  }
  
  # restoring graphical parameters
  par(opar)
}
gc()
```


## Calculate diversity indices for the whole network.  

Calculate H2' for the network (the higher the value the more selective the OTUs) and d' (same for samples, ranges from 0, no specialization, to 1, perfect specialist). d' for OTUs is calculated later.

```{r div_network, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){

  Htwo <- H2fun(OTUmatrixbip)
  dprimefood <- dfun(OTUmatrixbip)
  
  Htwo
  dprimefood

}
```

## Calculate taxa and sample statistics.  

A number of statistics are useful in the characterization for nodes of both levels (OTUs, samples). For their interpretation refer to this [vignette](https://cran.r-project.org/web/packages/bipartite/vignettes/Intro2bipartite.pdf) and to papers on the bipartite package and on pollination networks in general.  
A few plots are also generated: they are supposed to make it easier to identify specialist or generalist taxa.  

```{r sample_taxa_stats, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){
  #########1#########2#########3#########4#########5#########6#########7#########8
  # Calculate statistics for OTU nodes and sample nodes (filtered network) and  
  # save them in dataframes
  slevelstats <- specieslevel(OTUmatrixbip)
  OTUstats <- slevelstats$`higher level`
  # join with relative abundance
  OTUfreqs <- colSums(OTUmatrixbip)/sum(OTUmatrixbip)
  OTUstats <- cbind(OTUstats,OTUfreqs)
  samplestats <- slevelstats$`lower level`
  # join the Class
  OTUstats$label <- row.names(OTUstats)
  OTUstats <- left_join(OTUstats, select(input_data$taxa_metadata, label, class))
  OTUstats$Class <- as.factor(OTUstats$class)
  # plot d values
  OTUdab <- OTUstats %>% dplyr::select(label, d, OTUfreqs, class) %>% 
    dplyr::arrange(desc(d))
  
  # if the number of taxa is > 50 only the first 50 (most specialist) will be used
  
  OTUdab_toplot <- if(nrow(OTUdab)>50) slice(OTUdab, 1:50) else OTUdab
  dabplotwarning <- ifelse(nrow(OTUdab)>50,
                           str_wrap(
                             str_c("Warning: only the 50 taxa with highest values of specialization, out of ",
                                 nrow(OTUdab), " taxa in the dataset are being plotted"), 50
                             ),
                           "")
  
  
  dabplot <- ggplot(data = OTUdab_toplot, aes(x=d, 
                                       y = reorder(factor(label), d),
                                       size = OTUfreqs, 
                                       colour = class))
  # use alternative palettes and styles depending on the number of categories
  dabtitle <- str_c("Specialization (d) and abundance plot")
  dabsubtitle <- ifelse(dabplotwarning !="", dabplotwarning, waiver())
  
  if(n_distinct(OTUdab_toplot$class)<=12){
    dabplot + geom_point() + 
      scale_color_brewer(type = "qual", palette = "Paired") + 
      labs(y = "taxa", size = "rel. ab.", title = dabtitle, subtitle = dabsubtitle) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5), 
            plot.subtitle = element_text(hjust=0.5))
  } else {
    dabplot_palette <- myOTUcolorsbip
    names(dabplot_palette) <- myOTUtextbip
    dabplot + geom_point() + 
      scale_color_manual(values = dabplot_palette) + 
      labs(y = "taxa", size = "rel. ab.", title = dabtitle, subtitle = dabsubtitle) +
      theme_bw() +
      theme(axis.text.y = element_text(size = 16/log2(n_distinct(OTUdab_toplot$class))),
            plot.title = element_text(hjust = 0.5), 
            plot.subtitle = element_text(hjust=0.5))
  }
  
  if (savegraph) {
    ggsave(filename = str_c(file_name_prefix, "_dabplot",gfileext), 
           width = 7, height = 5, dpi = graphresolution)
  }
  # plot degree vs betweeness, only the OTUs with the top 20% values are labeled
  OTUstats$OTUlabel <- as.character(rep("",nrow(OTUstats)))
  lbl <- which(OTUstats$normalised.degree >= quantile(OTUstats$normalised.degree, 0.80))
  OTUstats$OTUlabel[lbl] <- OTUstats$label[lbl] 
  lbl <- which(OTUstats$weighted.betweenness != 0)
  OTUstats$OTUlabel[lbl] <- OTUstats$label[lbl] 
  degbplot <- ggplot(data = OTUstats, aes(x = normalised.degree,
                                          y = weighted.betweenness,
                                          colour = Class,
                                          size = OTUfreqs))
  if(n_distinct(OTUstats$class)<=12){
    degbplot + geom_point() + 
      geom_text_repel(aes(label = OTUlabel), colour = "black", 
                      alpha = 0.6, size = 3) + 
      labs(x = "normalised degree", y = "weighted betweenness") +
      scale_color_brewer(type = "qual", palette = "Paired") + 
      theme_bw()
  } else {
    degplot_palette <- myOTUcolorsbip
    names(degplot_palette) <- myOTUtextbip
    degbplot + geom_point() + 
      geom_text_repel(aes(label = OTUlabel), colour = "black", 
                      alpha = 0.6, size = 3) + 
      labs(x = "normalised degree", y = "weighted betweenness") +
      scale_color_manual(values = degplot_palette) + 
      theme_bw()
  }
  
  if (savegraph) {
    ggsave(filename = str_c(file_name_prefix, "_degbplot",gfileext), 
           width = 7, height = 5, dpi = graphresolution)
  }
}
```

## Degree distribution, filtered network.  

The degree distribution is recalculated and plotted for the filtered network.  


```{r deg_dist_filtered, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){

  # Recalculate degree distributions, separately for OTU and samples
  # using the filtered matrix
  OTUddf <- as.data.frame(degreedistr(OTUmatrixbip, level = "higher", 
                                      plot.it = FALSE))
  degreedistr(OTUmatrixf, level = "higher")
  Sampleddf <- as.data.frame(degreedistr(OTUmatrixbip, level = "lower", 
                                         plot.it = FALSE))
  degreedistr(OTUmatrixbip, level = "lower")

}
```


## Calculate modules.  

This chunk identifies modules of highly connected nodes and may be useful to identify sample groups specific microbiota.  
The output is rather tricky and may be difficult to plot if there are too many taxa and sample groups.  

```{r modules, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){
  # Compute and plot modules, may need to tamper with labsize
  mylabsize <- 0.6
  
  moduleWebObject <- computeModules(OTUmatrixbip);
  plotModuleWeb(moduleWebObject, labsize = mylabsize)
  if (savegraph) {
    if (graphtype == "pdf") {
      pdf(file = paste(file_name, "modw.pdf", sep = ""), width = graphsizein, 
          height = graphsizein, paper = "default")
    } else {
      tiff(filename = paste(file_name, "modw.tif", sep = ""), 
           width = graphsizein, height = graphsizein, units = "in",
           res = graphresolution, compression = "none")
    }
    moduleWebObject <- computeModules(OTUmatrixbip);
    plotModuleWeb(moduleWebObject, labsize = mylabsize)
    dev.off()
  }
  
  # restoring graphical parameters
  par(opar)
}
```

## Network level stats.  

This are useful if you want to compare different networks. Again, refer to the documentation for the bipartite package for interpretation.  
The stats are saved and printed (depending on the verbose_output option).

```{r net_level_stats, dpi = 96, echo = F}
if(input_data$sample_agg == "exp. code"){
  # Calculate network level stats. Only some options are included.               #
  # For small networks you may run                                               #
  # netstats <- as.data.frame(networklevel(OTUmatrixf, index = "ALLBUTDD"        #
  # Run this only at the end, may cause crashes for large matrices.              #
  # Make sure you save files and export the plots before you run it              #
  netstats <- as.data.frame(networklevel(OTUmatrixbip, 
                                         index = c("connectance", 
                                                   "weighted connectance", 
                                                   "nestedness", 
                                                   "weighted nestedness", 
                                                   "cluster coefficient")))
  colnames(netstats)<-"index"
  
  if(verbose_output) netstats
  
  #########1#########2#########3#########4#########5#########6#########7#########8
  # Save individual dataframes (as .txt files) for future use                    # 
  #########1#########2#########3#########4#########5#########6#########7#########8
  write.table(OTUstats, file = str_c(file_name_prefix, "_OTUstats.txt"), 
              append = FALSE, sep = "\t", col.names = TRUE, row.names = TRUE)
  write.table(samplestats, file = str_c(file_name_prefix, "_samplestats.txt"), 
              append = FALSE, sep = "\t", col.names = TRUE, row.names = TRUE)
  write.table(netstats, file = str_c(file_name_prefix,  "_netstats.txt", sep = ""), 
              append = FALSE, sep = "\t", col.names = TRUE, row.names = TRUE)
  
}
```

# A bonus bar plot.  

I am including this just because I like it a lot, but it may really oversimplify the structure of the microbial community. The relative abundance for the top x (set in options) taxa is plotted; all the other taxa are pooled under Other.

```{r bonus_plot, dpi = 96, echo = F}
OTUsums <- colSums(OTUmatrixbip)
# topx should be <20 and definitely <25
topxOTUnodesab <- names(OTUsums[order(OTUsums, decreasing = TRUE)])[1:topx]
OTUmatrixf3 <- OTUmatrixbip[,which(colnames(OTUmatrixbip) %in% topxOTUnodesab)]
if (pool) {
  if (rarefy_flag){
    sampleSums <- round(rarennbip*(totseqs-totseqsbip)/totseqs,0)+rarennbip
  } else {sampleSums <- totseqs}
} else {
  sampleSums <- rowSums(OTUmatrixbip)
}
OTUmatrixf3 <- OTUmatrixf3/sampleSums
Other <- 1-rowSums(OTUmatrixf3)
OTUmatrixf3 <- cbind(OTUmatrixf3, Other)

ET5 <- melt(OTUmatrixf3, value.name = "Weight")
colnames(ET5)[1:2] <- c("Sample", "Taxa")
taxa_levels <- unique(ET5$Taxa)
if ("Other" %in% taxa_levels) {
  taxa_levels <- c("Other",setdiff(taxa_levels,"Other"))
}
ET5$Taxa <- factor(ET5$Taxa, levels = taxa_levels) 
# make a palette
ncols <- nlevels(ET5$Taxa)
# make a qualitative color palette
bp_palette <- distinctColorPalette(ncols)
names(bp_palette) <- levels(ET5$OTU)
mygtitle <- paste("Relative abundance, top", ncols, "taxa (based on tot seqs)")

sbplot <- ggplot(data = ET5, aes(x = Sample, y= Weight, fill = Taxa))
if (topx<=12) {
  sbplot + geom_col(position = "fill") + 
    labs(title = str_wrap(mygtitle,40),
         x= "Samples/Sample groups",
         y= "Relative abundance",
         fill = "taxa") +
    scale_fill_brewer(type = "qual", palette = "Paired") +
    theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
          panel.background= element_rect(fill = "white"),
          legend.key.size = unit(0.2, "in"),
          plot.title = element_text(hjust = 0.5))
} else {
  sbplot + geom_col(position = "fill") + 
    labs(title = str_wrap(mygtitle,40),
         x= "Samples/Sample groups",
         y= "Relative abundance",
         fill = "taxa") +
    scale_fill_manual(values = bp_palette) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          panel.background= element_rect(fill = "white"),
          legend.key.size = unit(0.2, "in"),
          plot.title = element_text(hjust = 0.5))
}
if (savegraph) {
  ggsave(str_c(file_name_prefix, "_topxab", gfileext), 
         width = 7, height = 5, dpi = graphresolution)
}
```


# Citations and references.

## References.

Here is a list of references for FoodMicrobionet papers and for papers whose data were used for this data set. Be aware that:  

*  if the aggregation level for samples was "samples" a given subset of samples can be always by uniquely attributed to a given paper;  

*  if the aggregation level was "exp. code" then samples from different studies may be aggregated under the same "exp. code" category.

```{r citations_1, echo = F}
kable(input_data$references, col.names = c("Study", "Reference", "DOI"))
```


## Citations for R packages used in this script.  

The data used in this report were extracted from FoodMicrobionet using the ShinyFMBN app.  

`r input_data$version`  

```{r citations_packages}

all_packages <- c("base", .cran_packages)
map(all_packages, citation)

# for reproducibility reasins you should also run the following command
# sessionInfo()

```

## Copyright notice.  

v2.2 9/1/2022
This .Rmd file was created by Eugenio Parente, Universit√† degli Studi della Basilicata.  
The checkpackages function is derived from [this post](http://tinyurl.com/jjwyzph).  
The code for making qualitative palette is derived from [this article](http://tinyurl.com/hawqufy).  
The code for heat maps is modified from an article on the [Molecular ecologist blog](http://tinyurl.com/hxxbmvz).  
**The code is under [MIT](https://opensource.org/licenses/MIT) license**
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**Text and examples are under [CC BY-ND 4.0 international](https://creativecommons.org/licenses/by-nd/4.0/) licence**


_Finis. Pro bono, malum_ 